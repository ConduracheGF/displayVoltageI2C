///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR      16/Jan/2026  17:06:00
// Copyright 1996-2022 IAR Systems AB.
//
//    Source file  =  
//        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\usart_round_buff.c
//    Command line =  
//        -f C:\Users\STUDEN~1.DES\AppData\Local\Temp\EW88B4.tmp
//        (C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\usart_round_buff.c
//        --cpu=m1280 -ms -o
//        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\Obj
//        -lC
//        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\List
//        -lA
//        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\List
//        -y --initializers_in_flash --no_cse --no_inline --no_code_motion
//        --no_cross_call --no_clustering --no_tbaa --debug
//        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
//        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
//    Locale       =  English_GBR.1252
//    List file    =  
//        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\List\usart_round_buff.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME usart_round_buff

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "ATmega1280"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "true"
        RTMODEL "__memory_model", "2"
        RTMODEL "__no_rampd", "enabled"
        RTMODEL "__rt_version", "3"
        RTMODEL "__vtable_memory", "__nearflash"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?EPILOGUE_B8_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?PROLOGUE8_L09
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?Register_R6_is_cg_reg
        EXTERN ?Register_R7_is_cg_reg
        EXTERN ?SS_DIVMOD_L02

        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC is_empty
        PUBLIC is_full
        PUBLIC `pop`
        PUBLIC `push`
        PUBLIC push_vec
        
          CFI Names cfiNames0
          CFI StackFrame CFA_Y Y DATA
          CFI StackFrame CFA_SP SP DATA
          CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
          CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
          CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
          CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
          CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
          CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
          CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
          CFI ResourceParts SP SPH, SPL
          CFI ResourceParts Y R29, R28
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign 1
          CFI ReturnAddress ?Ret CODE
          CFI CFA_Y Y+0
          CFI CFA_SP SP+2
          CFI ?RetPad 0
          CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
          CFI ?RetLow Frame(CFA_SP, 0)
          CFI ?Ret Concat
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 SameValue
          CFI R13 SameValue
          CFI R14 SameValue
          CFI R15 SameValue
          CFI R16 Undefined
          CFI R17 Undefined
          CFI R18 Undefined
          CFI R19 Undefined
          CFI R20 Undefined
          CFI R21 Undefined
          CFI R22 Undefined
          CFI R23 Undefined
          CFI R24 SameValue
          CFI R25 SameValue
          CFI R26 SameValue
          CFI R27 SameValue
          CFI R28 Undefined
          CFI R29 Undefined
          CFI R30 Undefined
          CFI R31 Undefined
          CFI ?RetHighByteMask SameValue
          CFI SPH Undefined
          CFI SPL Undefined
          CFI EndCommon cfiCommon0
        
// C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\usart_round_buff.c
//    1 #include "usart_round_buff.h"
//    2 
//    3 // Funcție folosită pentru adăugarea unui caracter în bufferul circular

        RSEG `CODE`:CODE:NOROOT(1)
//    4 int16_t push(round_buff_s *inBuffer, uint8_t data) {
`push`:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function `push`
        CODE
        CALL    ?PROLOGUE4_L09
          CFI R27 Frame(CFA_Y, -1)
          CFI R26 Frame(CFA_Y, -2)
          CFI R25 Frame(CFA_Y, -3)
          CFI R24 Frame(CFA_Y, -4)
          CFI CFA_Y Y+4
        MOVW    R25:R24, R17:R16
        MOV     R26, R18
//    5   /*
//    6   * Se calculează poziția următoare a indicelui head folosind operația
//    7   * modulo pentru comportament circular.
//    8   */
//    9   uint8_t next_head = (inBuffer->head + 1) % BUFFER_SIZE;
        MOVW    R31:R30, R25:R24
        SUBI    R30, 192
        SBCI    R31, 255
        LD      R16, Z
        LDI     R17, 0
        SUBI    R16, 255
        SBCI    R17, 255
        LDI     R20, 64
        LDI     R21, 0
          CFI FunCall ?SS_DIVMOD_L02
        CALL    ?SS_DIVMOD_L02
        MOV     R27, R20
//   10   /*
//   11   * Dacă bufferul nu este plin, se inserează caracterul și
//   12   * se actualizează indicele head.
//   13   */
//   14   if (!is_full(inBuffer)) {
        MOVW    R17:R16, R25:R24
          CFI FunCall is_full
        RCALL   is_full
        OR      R16, R17
        BRNE    ??push_0
//   15     inBuffer->buffer[inBuffer->head] = data;
        MOVW    R31:R30, R25:R24
        SUBI    R30, 192
        SBCI    R31, 255
        LD      R16, Z
        LDI     R17, 0
        MOVW    R31:R30, R25:R24
        ADD     R30, R16
        ADC     R31, R17
        ST      Z, R26
//   16     inBuffer->head = next_head;
        MOVW    R31:R30, R25:R24
        SUBI    R30, 192
        SBCI    R31, 255
        ST      Z, R27
//   17     // Returnează 1 pentru succes
//   18     return 1;
        LDI     R16, 1
        LDI     R17, 0
        RJMP    ??push_1
//   19   } else
//   20     // Returnează 0 dacă bufferul este plin
//   21     return 0;
??push_0:
        LDI     R16, 0
        LDI     R17, 0
??push_1:
        LDI     R30, 4
        JMP     ?EPILOGUE_B4_L09
//   22 }
          CFI EndBlock cfiBlock0
//   23 
//   24 // Funcție folosită pentru extragerea unui caracter din buffer

        RSEG `CODE`:CODE:NOROOT(1)
//   25 uint8_t pop(round_buff_s *inBuffer) {
`pop`:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function `pop`
        CODE
        ST      -Y, R25
          CFI R25 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        ST      -Y, R24
          CFI R24 Frame(CFA_Y, -2)
          CFI CFA_Y Y+2
        MOVW    R25:R24, R17:R16
//   26   /*
//   27   * Dacă bufferul nu este gol, se preia caracterul din poziția tail
//   28   * și se actualizează indicele tail pentru comportament circular.
//   29   */
//   30   if (!is_empty(inBuffer)) {
        MOVW    R17:R16, R25:R24
          CFI FunCall is_empty
        RCALL   is_empty
        OR      R16, R17
        BRNE    ??pop_0
//   31     uint8_t data = inBuffer->buffer[inBuffer->tail];
        MOVW    R31:R30, R25:R24
        SUBI    R30, 191
        SBCI    R31, 255
        LD      R16, Z
        LDI     R17, 0
        MOVW    R31:R30, R25:R24
        ADD     R30, R16
        ADC     R31, R17
        LD      R18, Z
//   32     inBuffer->tail = (inBuffer->tail + 1) % BUFFER_SIZE;
        MOVW    R31:R30, R25:R24
        SUBI    R30, 191
        SBCI    R31, 255
        LD      R16, Z
        LDI     R17, 0
        SUBI    R16, 255
        SBCI    R17, 255
        LDI     R20, 64
        LDI     R21, 0
          CFI FunCall ?SS_DIVMOD_L02
        CALL    ?SS_DIVMOD_L02
        MOVW    R31:R30, R25:R24
        SUBI    R30, 191
        SBCI    R31, 255
        ST      Z, R20
//   33     // Returnează caracterul extras
//   34     return data;
        MOV     R16, R18
        RJMP    ??pop_1
//   35   } else {
//   36     // Returnează 0 dacă bufferul este gol
//   37     return 0;
??pop_0:
        LDI     R16, 0
??pop_1:
        LD      R24, Y+
          CFI R24 SameValue
          CFI CFA_Y Y+1
        LD      R25, Y+
          CFI R25 SameValue
          CFI CFA_Y Y+0
        RET
//   38   }
//   39 }
          CFI EndBlock cfiBlock1
//   40 
//   41 // Funcție folosită pentru adăugarea unui șir de caractere în buffer

        RSEG `CODE`:CODE:NOROOT(1)
//   42 int16_t push_vec(round_buff_s *inBuffer, uint8_t data[], int16_t length) {
push_vec:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function push_vec
        CODE
        CALL    ?PROLOGUE8_L09
          CFI R7 Frame(CFA_Y, -1)
          CFI R6 Frame(CFA_Y, -2)
          CFI R5 Frame(CFA_Y, -3)
          CFI R4 Frame(CFA_Y, -4)
          CFI R27 Frame(CFA_Y, -5)
          CFI R26 Frame(CFA_Y, -6)
          CFI R25 Frame(CFA_Y, -7)
          CFI R24 Frame(CFA_Y, -8)
          CFI CFA_Y Y+8
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        MOVW    R5:R4, R17:R16
        MOVW    R7:R6, R19:R18
        MOVW    R27:R26, R21:R20
//   43   int16_t i;
//   44   /*
//   45   * Se parcurge fiecare caracter din șir și se încearcă adăugarea lui.
//   46   * În caz că bufferul se umple, se oprește inserarea.
//   47   */
//   48   for (i = 0; i < length; i++) {
        LDI     R24, 0
        LDI     R25, 0
??push_vec_0:
        CP      R24, R26
        CPC     R25, R27
        BRGE    ??push_vec_1
//   49     uint8_t verif = push(inBuffer, data[i]);
        MOVW    R31:R30, R7:R6
        ADD     R30, R24
        ADC     R31, R25
        LD      R18, Z
        MOVW    R17:R16, R5:R4
          CFI FunCall `push`
        RCALL   `push`
//   50     if (verif == 0)
        TST     R16
        BREQ    ??push_vec_1
//   51       break;
//   52   }
        ADIW    R25:R24, 1
        RJMP    ??push_vec_0
//   53 
//   54   // Returnează numărul de caractere adăugate cu succes
//   55   return i;
??push_vec_1:
        MOVW    R17:R16, R25:R24
        LDI     R30, 8
        JMP     ?EPILOGUE_B8_L09
//   56 }
          CFI EndBlock cfiBlock2
//   57 
//   58 // Funcție folosită pentru verificarea dacă bufferul este gol

        RSEG `CODE`:CODE:NOROOT(1)
//   59 int16_t is_empty(round_buff_s *inBuffer) {
is_empty:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function is_empty
          CFI NoCalls
        CODE
//   60   return (inBuffer->head == inBuffer->tail);
        MOVW    R31:R30, R17:R16
        SUBI    R30, 192
        SBCI    R31, 255
        LD      R18, Z
        SUBI    R16, 191
        SBCI    R17, 255
        MOVW    R31:R30, R17:R16
        LD      R16, Z
        CP      R18, R16
        BRNE    ??is_empty_0
        LDI     R16, 1
        RJMP    ??is_empty_1
??is_empty_0:
        LDI     R16, 0
??is_empty_1:
        LDI     R17, 0
        RET
//   61 }
          CFI EndBlock cfiBlock3
//   62 
//   63 // Funcție folosită pentru verificarea dacă bufferul este plin

        RSEG `CODE`:CODE:NOROOT(1)
//   64 int16_t is_full(round_buff_s *inBuffer) {
is_full:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function is_full
        CODE
        MOVW    R19:R18, R17:R16
//   65   return ((inBuffer->head + 1) % BUFFER_SIZE) == inBuffer->tail;
        MOVW    R31:R30, R19:R18
        SUBI    R30, 192
        SBCI    R31, 255
        LD      R16, Z
        LDI     R17, 0
        SUBI    R16, 255
        SBCI    R17, 255
        LDI     R20, 64
        LDI     R21, 0
          CFI FunCall ?SS_DIVMOD_L02
        CALL    ?SS_DIVMOD_L02
        SUBI    R18, 191
        SBCI    R19, 255
        MOVW    R31:R30, R19:R18
        LD      R16, Z
        LDI     R17, 0
        CP      R20, R16
        CPC     R21, R17
        BRNE    ??is_full_0
        LDI     R16, 1
        RJMP    ??is_full_1
??is_full_0:
        LDI     R16, 0
??is_full_1:
        LDI     R17, 0
        RET
//   66 }
          CFI EndBlock cfiBlock4

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,022H
__?EEARH:

        END
// 
// 284 bytes in segment CODE
// 
// 284 bytes of CODE memory
//
//Errors: none
//Warnings: none
