###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       16/Jan/2026  17:06:00
# Copyright 1996-2022 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\usart_my_lib.c
#    Command line =  
#        -f C:\Users\STUDEN~1.DES\AppData\Local\Temp\EW88B2.tmp
#        (C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\usart_my_lib.c
#        --cpu=m1280 -ms -o
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\Obj
#        -lC
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\List
#        -lA
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\List
#        -y --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
#    Locale       =  English_GBR.1252
#    List file    =  
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\List\usart_my_lib.lst
#    Object file  =  
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\Obj\usart_my_lib.r90
#
###############################################################################

C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\usart_my_lib.c
      1          #include "usart_my_lib.h"
      2          
      3          // Buffer auxiliar pentru construirea șirului de caractere

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
      4          static uint8_t aux1[10] = { 0 }, aux2[10] = { 0 };
   \                     aux1:
   \   00000000                      DS8 10

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \                     aux2:
   \   00000000                      DS8 10
      5          
      6          // Funcția de transmitere a unui număr întreg pe serială

   \                                 In  segment CODE, align 2, keep-with-next
      7          void integerTransmit(void *p) {
   \                     integerTransmit:
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004   0138               MOVW    R7:R6, R17:R16
      8            // Se inițializează indicii pentru construcția șirului de caractere
      9            int16_t index = 0, i = 0;
   \   00000006   E0A0               LDI     R26, 0
   \   00000008   E0B0               LDI     R27, 0
   \   0000000A   2444               CLR     R4
   \   0000000C   2455               CLR     R5
     10            // Se preia valoarea întreagă din pointer
     11            int16_t x = (*(int16_t *)(p));
   \   0000000E   01F3               MOVW    R31:R30, R7:R6
   \   00000010   8180               LD      R24, Z
   \   00000012   8191               LDD     R25, Z+1
     12            // Se tratează cazul numerelor negative
     13            if (x < 0) {
   \   00000014   2399               TST     R25
   \   00000016   F462               BRPL    ??integerTransmit_0
     14              aux1[index] = '-';  // Se adaugă semnul minus
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   0000001C   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   0000001E   E20D               LDI     R16, 45
   \   00000020   8300               ST      Z, R16
     15              index++;
   \   00000022   9611               ADIW    R27:R26, 1
     16              x *= (-1);
   \   00000024   018C               MOVW    R17:R16, R25:R24
   \   00000026   EF4F               LDI     R20, 255
   \   00000028   EF5F               LDI     R21, 255
   \   0000002A   ........           CALL    ?S_EC_MUL_L02
   \   0000002E   01C8               MOVW    R25:R24, R17:R16
     17              // Se convertește la valoare pozitivă
     18            }
     19            // Se extrag cifrele numărului în ordine inversă
     20            do {
     21              // Se convertește cifra la caracter ASCII
     22              uint8_t c = x % 10 + '0';
   \                     ??integerTransmit_0:
   \   00000030   E04A               LDI     R20, 10
   \   00000032   E050               LDI     R21, 0
   \   00000034   018C               MOVW    R17:R16, R25:R24
   \   00000036   ........           CALL    ?SS_DIVMOD_L02
   \   0000003A   2F24               MOV     R18, R20
   \   0000003C   5D20               SUBI    R18, 208
     23          
     24              // Se stochează temporar în buffer auxiliar
     25              aux2[i] = c;
   \   0000003E   01F2               MOVW    R31:R30, R5:R4
   \   00000040   ....               SUBI    R30, LOW((-(aux2) & 0xFFFF))
   \   00000042   ....               SBCI    R31, (-(aux2) & 0xFFFF) >> 8
   \   00000044   8320               ST      Z, R18
     26              i++;
   \   00000046   E001               LDI     R16, 1
   \   00000048   0E40               ADD     R4, R16
   \   0000004A   E000               LDI     R16, 0
   \   0000004C   1E50               ADC     R5, R16
     27              // Se reduce numărul
     28              x = x / 10;
   \   0000004E   E04A               LDI     R20, 10
   \   00000050   E050               LDI     R21, 0
   \   00000052   018C               MOVW    R17:R16, R25:R24
   \   00000054   ........           CALL    ?SS_DIVMOD_L02
   \   00000058   01C8               MOVW    R25:R24, R17:R16
     29            } while (x != 0);
   \   0000005A   2F08               MOV     R16, R24
   \   0000005C   2B09               OR      R16, R25
   \   0000005E   F741               BRNE    ??integerTransmit_0
     30            // Se copiază cifrele în ordinea corectă în bufferul final
     31            for (int16_t j = i - 1; j >= 0; j--) {
   \   00000060   0182               MOVW    R17:R16, R5:R4
   \   00000062   5001               SUBI    R16, 1
   \   00000064   4010               SBCI    R17, 0
   \                     ??integerTransmit_1:
   \   00000066   2311               TST     R17
   \   00000068   F062               BRMI    ??integerTransmit_2
     32              aux1[index] = aux2[j];
   \   0000006A   01F8               MOVW    R31:R30, R17:R16
   \   0000006C   ....               SUBI    R30, LOW((-(aux2) & 0xFFFF))
   \   0000006E   ....               SBCI    R31, (-(aux2) & 0xFFFF) >> 8
   \   00000070   8120               LD      R18, Z
   \   00000072   01FD               MOVW    R31:R30, R27:R26
   \   00000074   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   00000076   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   00000078   8320               ST      Z, R18
     33              index++;
   \   0000007A   9611               ADIW    R27:R26, 1
     34            }
   \   0000007C   5001               SUBI    R16, 1
   \   0000007E   4010               SBCI    R17, 0
   \   00000080   CFF2               RJMP    ??integerTransmit_1
     35            // Se adaugă caracterele de sfârșit de linie
     36            aux1[index] = '\n';
   \                     ??integerTransmit_2:
   \   00000082   01FD               MOVW    R31:R30, R27:R26
   \   00000084   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   00000086   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   00000088   E00A               LDI     R16, 10
   \   0000008A   8300               ST      Z, R16
     37            index++;
   \   0000008C   9611               ADIW    R27:R26, 1
     38            aux1[index] = '\r';
   \   0000008E   01FD               MOVW    R31:R30, R27:R26
   \   00000090   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   00000092   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   00000094   E00D               LDI     R16, 13
   \   00000096   8300               ST      Z, R16
     39            index++;
   \   00000098   9611               ADIW    R27:R26, 1
     40            // Se transmite șirul format către modulul USART
     41            USART_transmit_string(aux1, index);
   \   0000009A   019D               MOVW    R19:R18, R27:R26
   \   0000009C   ....               LDI     R16, LOW(aux1)
   \   0000009E   ....               LDI     R17, (aux1) >> 8
   \   000000A0   ........           CALL    USART_transmit_string
     42          }
   \   000000A4   E0E8               LDI     R30, 8
   \   000000A6   ........           JMP     ?EPILOGUE_B8_L09
     43          
     44          // Funcția de transmitere a unui număr hexazecimal pe serială

   \                                 In  segment CODE, align 2, keep-with-next
     45          void hexadecimalTransmit(void *p) {
   \                     hexadecimalTransmit:
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004   0138               MOVW    R7:R6, R17:R16
     46            // Se preia valoarea întreagă din pointer
     47            int16_t x = *((int16_t *)(p));
   \   00000006   01F3               MOVW    R31:R30, R7:R6
   \   00000008   8180               LD      R24, Z
   \   0000000A   8191               LDD     R25, Z+1
     48            int16_t index = 0, i = 0;
   \   0000000C   E0A0               LDI     R26, 0
   \   0000000E   E0B0               LDI     R27, 0
   \   00000010   2444               CLR     R4
   \   00000012   2455               CLR     R5
     49            // Se adaugă prefixul "0x" pentru format hexazecimal
     50            aux1[index] = '0';
   \   00000014   01FD               MOVW    R31:R30, R27:R26
   \   00000016   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   00000018   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   0000001A   E300               LDI     R16, 48
   \   0000001C   8300               ST      Z, R16
     51            index++;
   \   0000001E   9611               ADIW    R27:R26, 1
     52            aux1[index] = 'x';
   \   00000020   01FD               MOVW    R31:R30, R27:R26
   \   00000022   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   00000024   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   00000026   E708               LDI     R16, 120
   \   00000028   8300               ST      Z, R16
     53            index++;
   \   0000002A   9611               ADIW    R27:R26, 1
     54            // Se extrag cifrele hexazecimale în ordine inversă
     55            do {
     56              uint8_t a = x & 0x0F;  // Se preiau cei 4 biți cei mai mici
   \                     ??hexadecimalTransmit_0:
   \   0000002C   2F28               MOV     R18, R24
   \   0000002E   702F               ANDI    R18, 0x0F
     57              // Se convertește valoarea la caracter ASCII
     58              if (a <= 9) {
   \   00000030   302A               CPI     R18, 10
   \   00000032   F438               BRCC    ??hexadecimalTransmit_1
     59                aux2[i] = a + '0';
   \   00000034   2F02               MOV     R16, R18
   \   00000036   5D00               SUBI    R16, 208
   \   00000038   01F2               MOVW    R31:R30, R5:R4
   \   0000003A   ....               SUBI    R30, LOW((-(aux2) & 0xFFFF))
   \   0000003C   ....               SBCI    R31, (-(aux2) & 0xFFFF) >> 8
   \   0000003E   8300               ST      Z, R16
   \   00000040   C006               RJMP    ??hexadecimalTransmit_2
     60              } else {
     61                aux2[i] = a + 'A' - 10;
   \                     ??hexadecimalTransmit_1:
   \   00000042   2F02               MOV     R16, R18
   \   00000044   5C09               SUBI    R16, 201
   \   00000046   01F2               MOVW    R31:R30, R5:R4
   \   00000048   ....               SUBI    R30, LOW((-(aux2) & 0xFFFF))
   \   0000004A   ....               SBCI    R31, (-(aux2) & 0xFFFF) >> 8
   \   0000004C   8300               ST      Z, R16
     62              }
     63              i++;
   \                     ??hexadecimalTransmit_2:
   \   0000004E   E001               LDI     R16, 1
   \   00000050   0E40               ADD     R4, R16
   \   00000052   E000               LDI     R16, 0
   \   00000054   1E50               ADC     R5, R16
     64              x >>= 4;  // Se face shiftare pentru următoarea cifră
   \   00000056   E044               LDI     R20, 4
   \   00000058   018C               MOVW    R17:R16, R25:R24
   \   0000005A   ........           CALL    ?SS_SHR_L02
   \   0000005E   01C8               MOVW    R25:R24, R17:R16
     65            } while (x != 0);
   \   00000060   2F08               MOV     R16, R24
   \   00000062   2B09               OR      R16, R25
   \   00000064   F719               BRNE    ??hexadecimalTransmit_0
     66            // Se copiază cifrele în ordinea corectă
     67            for (int16_t j = i - 1; j >= 0; j--) {
   \   00000066   0182               MOVW    R17:R16, R5:R4
   \   00000068   5001               SUBI    R16, 1
   \   0000006A   4010               SBCI    R17, 0
   \                     ??hexadecimalTransmit_3:
   \   0000006C   2311               TST     R17
   \   0000006E   F062               BRMI    ??hexadecimalTransmit_4
     68              aux1[index] = aux2[j];
   \   00000070   01F8               MOVW    R31:R30, R17:R16
   \   00000072   ....               SUBI    R30, LOW((-(aux2) & 0xFFFF))
   \   00000074   ....               SBCI    R31, (-(aux2) & 0xFFFF) >> 8
   \   00000076   8120               LD      R18, Z
   \   00000078   01FD               MOVW    R31:R30, R27:R26
   \   0000007A   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   0000007C   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   0000007E   8320               ST      Z, R18
     69          
     70              index++;
   \   00000080   9611               ADIW    R27:R26, 1
     71            }
   \   00000082   5001               SUBI    R16, 1
   \   00000084   4010               SBCI    R17, 0
   \   00000086   CFF2               RJMP    ??hexadecimalTransmit_3
     72            // Se transmite șirul format către modulul USART
     73            USART_transmit_string(aux1, index);
   \                     ??hexadecimalTransmit_4:
   \   00000088   019D               MOVW    R19:R18, R27:R26
   \   0000008A   ....               LDI     R16, LOW(aux1)
   \   0000008C   ....               LDI     R17, (aux1) >> 8
   \   0000008E   ........           CALL    USART_transmit_string
     74          }
   \   00000092   E0E8               LDI     R30, 8
   \   00000094   ........           JMP     ?EPILOGUE_B8_L09
     75          
     76          // Funcția de transmitere a unui număr de tip double pe serială

   \                                 In  segment CODE, align 2, keep-with-next
     77          void doubleTransmit(void *p) {
   \                     doubleTransmit:
   \   00000000   ........           CALL    ?PROLOGUE16_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004                      REQUIRE ?Register_R12_is_cg_reg
   \   00000004                      REQUIRE ?Register_R13_is_cg_reg
   \   00000004                      REQUIRE ?Register_R14_is_cg_reg
   \   00000004                      REQUIRE ?Register_R15_is_cg_reg
   \   00000004   9722               SBIW    R29:R28, 2
   \   00000006   8308               ST      Y, R16
   \   00000008   8319               STD     Y+1, R17
     78            // Se preia valoarea double din pointer
     79            double x = (*(double *)(p));
   \   0000000A   81E8               LD      R30, Y
   \   0000000C   81F9               LDD     R31, Y+1
   \   0000000E   8080               LD      R8, Z
   \   00000010   8091               LDD     R9, Z+1
   \   00000012   80A2               LDD     R10, Z+2
   \   00000014   80B3               LDD     R11, Z+3
     80            int16_t index = 0;
   \   00000016   E0A0               LDI     R26, 0
   \   00000018   E0B0               LDI     R27, 0
     81            int16_t i = 0;
   \   0000001A   2466               CLR     R6
   \   0000001C   2477               CLR     R7
     82            // Se tratează cazul numerelor negative
     83            if (x < 0) {
   \   0000001E   0184               MOVW    R17:R16, R9:R8
   \   00000020   0195               MOVW    R19:R18, R11:R10
   \   00000022   E040               LDI     R20, 0
   \   00000024   E050               LDI     R21, 0
   \   00000026   E060               LDI     R22, 0
   \   00000028   E070               LDI     R23, 0
   \   0000002A   ........           CALL    ?F_CMP_LT_L04
   \   0000002E   F440               BRCC    ??doubleTransmit_0
     84              aux1[index++] = '-';
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   00000034   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   00000036   E20D               LDI     R16, 45
   \   00000038   8300               ST      Z, R16
   \   0000003A   9611               ADIW    R27:R26, 1
     85              x = -x;
   \   0000003C   E800               LDI     R16, 128
   \   0000003E   26B0               EOR     R11, R16
     86            }
     87            // Se separă partea întreagă de partea fracționară
     88            int16_t int_part = (int16_t)x;
   \                     ??doubleTransmit_0:
   \   00000040   0184               MOVW    R17:R16, R9:R8
   \   00000042   0195               MOVW    R19:R18, R11:R10
   \   00000044   ........           CALL    ?F2SL_L04
   \   00000048   0128               MOVW    R5:R4, R17:R16
     89            double frac = x - int_part;
   \   0000004A   0182               MOVW    R17:R16, R5:R4
   \   0000004C   2F21               MOV     R18, R17
   \   0000004E   0F22               LSL     R18
   \   00000050   0B22               SBC     R18, R18
   \   00000052   2F32               MOV     R19, R18
   \   00000054   ........           CALL    ?SL2F_L04
   \   00000058   01A8               MOVW    R21:R20, R17:R16
   \   0000005A   01B9               MOVW    R23:R22, R19:R18
   \   0000005C   0184               MOVW    R17:R16, R9:R8
   \   0000005E   0195               MOVW    R19:R18, R11:R10
   \   00000060   ........           CALL    ?F_SUB_L04
   \   00000064   0168               MOVW    R13:R12, R17:R16
   \   00000066   0179               MOVW    R15:R14, R19:R18
     90            // Se păstrează două zecimale
     91            int16_t frac_part = (int16_t)(frac * 100 + 0.5);
   \   00000068   0186               MOVW    R17:R16, R13:R12
   \   0000006A   0197               MOVW    R19:R18, R15:R14
   \   0000006C   E040               LDI     R20, 0
   \   0000006E   E050               LDI     R21, 0
   \   00000070   EC68               LDI     R22, 200
   \   00000072   E472               LDI     R23, 66
   \   00000074   ........           CALL    ?F_MUL_L04
   \   00000078   E040               LDI     R20, 0
   \   0000007A   E050               LDI     R21, 0
   \   0000007C   E060               LDI     R22, 0
   \   0000007E   E37F               LDI     R23, 63
   \   00000080   ........           CALL    ?F_ADD_L04
   \   00000084   ........           CALL    ?F2SL_L04
   \   00000088   01C8               MOVW    R25:R24, R17:R16
     92            // Se procesează partea întreagă
     93            if (int_part == 0) {
   \   0000008A   2D04               MOV     R16, R4
   \   0000008C   2905               OR      R16, R5
   \   0000008E   F439               BRNE    ??doubleTransmit_1
     94              aux1[index++] = '0';
   \   00000090   01FD               MOVW    R31:R30, R27:R26
   \   00000092   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   00000094   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   00000096   E300               LDI     R16, 48
   \   00000098   8300               ST      Z, R16
   \   0000009A   9611               ADIW    R27:R26, 1
   \   0000009C   C02A               RJMP    ??doubleTransmit_2
     95            } else {
     96              while (int_part != 0) {
   \                     ??doubleTransmit_1:
   \   0000009E   2D04               MOV     R16, R4
   \   000000A0   2905               OR      R16, R5
   \   000000A2   F0B1               BREQ    ??doubleTransmit_3
     97                // Se convertește cifra la caracter ASCII
     98                uint8_t c = int_part % 10 + '0';
   \   000000A4   E04A               LDI     R20, 10
   \   000000A6   E050               LDI     R21, 0
   \   000000A8   0182               MOVW    R17:R16, R5:R4
   \   000000AA   ........           CALL    ?SS_DIVMOD_L02
   \   000000AE   2F24               MOV     R18, R20
   \   000000B0   5D20               SUBI    R18, 208
     99                // Se stochează temporar în buffer auxiliar
    100                aux2[i++] = c;
   \   000000B2   01F3               MOVW    R31:R30, R7:R6
   \   000000B4   ....               SUBI    R30, LOW((-(aux2) & 0xFFFF))
   \   000000B6   ....               SBCI    R31, (-(aux2) & 0xFFFF) >> 8
   \   000000B8   8320               ST      Z, R18
   \   000000BA   E001               LDI     R16, 1
   \   000000BC   0E60               ADD     R6, R16
   \   000000BE   E000               LDI     R16, 0
   \   000000C0   1E70               ADC     R7, R16
    101                // Se reduce valoarea
    102                int_part /= 10;
   \   000000C2   E04A               LDI     R20, 10
   \   000000C4   E050               LDI     R21, 0
   \   000000C6   0182               MOVW    R17:R16, R5:R4
   \   000000C8   ........           CALL    ?SS_DIVMOD_L02
   \   000000CC   0128               MOVW    R5:R4, R17:R16
   \   000000CE   CFE7               RJMP    ??doubleTransmit_1
    103              }
    104              // Se copiază cifrele în ordinea corectă
    105              for (int16_t j = i - 1; j >= 0; j--) {
   \                     ??doubleTransmit_3:
   \   000000D0   0193               MOVW    R19:R18, R7:R6
   \   000000D2   5021               SUBI    R18, 1
   \   000000D4   4030               SBCI    R19, 0
   \                     ??doubleTransmit_4:
   \   000000D6   2333               TST     R19
   \   000000D8   F062               BRMI    ??doubleTransmit_2
    106                aux1[index++] = aux2[j];
   \   000000DA   01F9               MOVW    R31:R30, R19:R18
   \   000000DC   ....               SUBI    R30, LOW((-(aux2) & 0xFFFF))
   \   000000DE   ....               SBCI    R31, (-(aux2) & 0xFFFF) >> 8
   \   000000E0   8100               LD      R16, Z
   \   000000E2   01FD               MOVW    R31:R30, R27:R26
   \   000000E4   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   000000E6   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   000000E8   8300               ST      Z, R16
   \   000000EA   9611               ADIW    R27:R26, 1
    107              }
   \   000000EC   5021               SUBI    R18, 1
   \   000000EE   4030               SBCI    R19, 0
   \   000000F0   CFF2               RJMP    ??doubleTransmit_4
    108            }
    109            // Se adaugă separatorul zecimal
    110            aux1[index++] = '.';
   \                     ??doubleTransmit_2:
   \   000000F2   01FD               MOVW    R31:R30, R27:R26
   \   000000F4   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   000000F6   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   000000F8   E20E               LDI     R16, 46
   \   000000FA   8300               ST      Z, R16
   \   000000FC   9611               ADIW    R27:R26, 1
    111            i = 0;
   \   000000FE   2466               CLR     R6
   \   00000100   2477               CLR     R7
    112            // Se procesează partea fracționară
    113            if (frac_part == 0) {
   \   00000102   2F08               MOV     R16, R24
   \   00000104   2B09               OR      R16, R25
   \   00000106   F469               BRNE    ??doubleTransmit_5
    114              aux1[index++] = '0';
   \   00000108   01FD               MOVW    R31:R30, R27:R26
   \   0000010A   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   0000010C   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   0000010E   E300               LDI     R16, 48
   \   00000110   8300               ST      Z, R16
   \   00000112   9611               ADIW    R27:R26, 1
    115              aux1[index++] = '0';
   \   00000114   01FD               MOVW    R31:R30, R27:R26
   \   00000116   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   00000118   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   0000011A   E300               LDI     R16, 48
   \   0000011C   8300               ST      Z, R16
   \   0000011E   9611               ADIW    R27:R26, 1
   \   00000120   C034               RJMP    ??doubleTransmit_6
    116            }
    117          
    118            else {
    119              if (frac_part < 10) {
   \                     ??doubleTransmit_5:
   \   00000122   308A               CPI     R24, 10
   \   00000124   E000               LDI     R16, 0
   \   00000126   0790               CPC     R25, R16
   \   00000128   F434               BRGE    ??doubleTransmit_7
    120                aux1[index++] = '0';  // Se adaugă zeroul pentru o cifră
   \   0000012A   01FD               MOVW    R31:R30, R27:R26
   \   0000012C   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   0000012E   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   00000130   E300               LDI     R16, 48
   \   00000132   8300               ST      Z, R16
   \   00000134   9611               ADIW    R27:R26, 1
    121              }
    122              // Se extrag cifrele fracționare în ordine inversă
    123              while (frac_part != 0) {
   \                     ??doubleTransmit_7:
   \   00000136   2F08               MOV     R16, R24
   \   00000138   2B09               OR      R16, R25
   \   0000013A   F0B1               BREQ    ??doubleTransmit_8
    124                uint8_t c = frac_part % 10 + '0';
   \   0000013C   E04A               LDI     R20, 10
   \   0000013E   E050               LDI     R21, 0
   \   00000140   018C               MOVW    R17:R16, R25:R24
   \   00000142   ........           CALL    ?SS_DIVMOD_L02
   \   00000146   2F24               MOV     R18, R20
   \   00000148   5D20               SUBI    R18, 208
    125                aux2[i++] = c;
   \   0000014A   01F3               MOVW    R31:R30, R7:R6
   \   0000014C   ....               SUBI    R30, LOW((-(aux2) & 0xFFFF))
   \   0000014E   ....               SBCI    R31, (-(aux2) & 0xFFFF) >> 8
   \   00000150   8320               ST      Z, R18
   \   00000152   E001               LDI     R16, 1
   \   00000154   0E60               ADD     R6, R16
   \   00000156   E000               LDI     R16, 0
   \   00000158   1E70               ADC     R7, R16
    126                frac_part /= 10;
   \   0000015A   E04A               LDI     R20, 10
   \   0000015C   E050               LDI     R21, 0
   \   0000015E   018C               MOVW    R17:R16, R25:R24
   \   00000160   ........           CALL    ?SS_DIVMOD_L02
   \   00000164   01C8               MOVW    R25:R24, R17:R16
   \   00000166   CFE7               RJMP    ??doubleTransmit_7
    127              }
    128              // Se copiază cifrele în ordinea corectă
    129              for (int16_t j = i - 1; j >= 0; j--) {
   \                     ??doubleTransmit_8:
   \   00000168   0193               MOVW    R19:R18, R7:R6
   \   0000016A   5021               SUBI    R18, 1
   \   0000016C   4030               SBCI    R19, 0
   \                     ??doubleTransmit_9:
   \   0000016E   2333               TST     R19
   \   00000170   F062               BRMI    ??doubleTransmit_6
    130                aux1[index++] = aux2[j];
   \   00000172   01F9               MOVW    R31:R30, R19:R18
   \   00000174   ....               SUBI    R30, LOW((-(aux2) & 0xFFFF))
   \   00000176   ....               SBCI    R31, (-(aux2) & 0xFFFF) >> 8
   \   00000178   8100               LD      R16, Z
   \   0000017A   01FD               MOVW    R31:R30, R27:R26
   \   0000017C   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   0000017E   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   00000180   8300               ST      Z, R16
   \   00000182   9611               ADIW    R27:R26, 1
    131              }
   \   00000184   5021               SUBI    R18, 1
   \   00000186   4030               SBCI    R19, 0
   \   00000188   CFF2               RJMP    ??doubleTransmit_9
    132            }
    133            // Se adaugă caracterele de sfârșit de linie
    134            aux1[index++] = '\n';
   \                     ??doubleTransmit_6:
   \   0000018A   01FD               MOVW    R31:R30, R27:R26
   \   0000018C   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   0000018E   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   00000190   E00A               LDI     R16, 10
   \   00000192   8300               ST      Z, R16
   \   00000194   9611               ADIW    R27:R26, 1
    135            aux1[index++] = '\r';
   \   00000196   01FD               MOVW    R31:R30, R27:R26
   \   00000198   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   0000019A   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   0000019C   E00D               LDI     R16, 13
   \   0000019E   8300               ST      Z, R16
   \   000001A0   9611               ADIW    R27:R26, 1
    136            // Se transmite șirul format către modulul USART
    137            USART_transmit_string(aux1, index);
   \   000001A2   019D               MOVW    R19:R18, R27:R26
   \   000001A4   ....               LDI     R16, LOW(aux1)
   \   000001A6   ....               LDI     R17, (aux1) >> 8
   \   000001A8   ........           CALL    USART_transmit_string
    138          }
   \   000001AC   9622               ADIW    R29:R28, 2
   \   000001AE   E1E0               LDI     R30, 16
   \   000001B0   ........           JMP     ?EPILOGUE_B16_L09
    139          // Se transmite un caracter pe serială

   \                                 In  segment CODE, align 2, keep-with-next
    140          void characterTransmit(void *p) {
   \                     characterTransmit:
   \   00000000   ........           CALL    ?PROLOGUE5_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004   01D8               MOVW    R27:R26, R17:R16
    141            // Se preia caracterul din pointer
    142            int8_t x = (*(int8_t *)(p));
   \   00000006   904C               LD      R4, X
    143            int16_t index = 0;
   \   00000008   E080               LDI     R24, 0
   \   0000000A   E090               LDI     R25, 0
    144            // Se adaugă caracterul în buffer
    145            aux1[index++] = x;
   \   0000000C   01FC               MOVW    R31:R30, R25:R24
   \   0000000E   ....               SUBI    R30, LOW((-(aux1) & 0xFFFF))
   \   00000010   ....               SBCI    R31, (-(aux1) & 0xFFFF) >> 8
   \   00000012   8240               ST      Z, R4
   \   00000014   9601               ADIW    R25:R24, 1
    146            // Se transmite caracterul către modulul USART
    147            USART_transmit_string(aux1, index);
   \   00000016   019C               MOVW    R19:R18, R25:R24
   \   00000018   ....               LDI     R16, LOW(aux1)
   \   0000001A   ....               LDI     R17, (aux1) >> 8
   \   0000001C   ........           CALL    USART_transmit_string
    148          }
   \   00000020   E0E5               LDI     R30, 5
   \   00000022   ........           JMP     ?EPILOGUE_B5_L09
    149          
    150          // Funcție de tip wrapper prin care se transmit valori de diverse tipuri

   \                                 In  segment CODE, align 2, keep-with-next
    151          void my_print(Tipuri tip, void *val) {
   \                     my_print:
   \   00000000   ........           CALL    ?PROLOGUE3_L09
   \   00000004   2FA0               MOV     R26, R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
    152            switch (tip) {
   \   00000008   2F0A               MOV     R16, R26
   \   0000000A   5000               SUBI    R16, 0
   \   0000000C   F039               BREQ    ??my_print_0
   \   0000000E   950A               DEC     R16
   \   00000010   F041               BREQ    ??my_print_1
   \   00000012   950A               DEC     R16
   \   00000014   F049               BREQ    ??my_print_2
   \   00000016   950A               DEC     R16
   \   00000018   F051               BREQ    ??my_print_3
   \   0000001A   C00B               RJMP    ??my_print_4
    153              case INTEGER:
    154                // Se transmite un număr întreg
    155                integerTransmit(val);
   \                     ??my_print_0:
   \   0000001C   018C               MOVW    R17:R16, R25:R24
   \   0000001E   ....               RCALL   integerTransmit
    156                break;
   \   00000020   C008               RJMP    ??my_print_4
    157              case HEX:
    158                // Se transmite un număr hexazecimal
    159                hexadecimalTransmit(val);
   \                     ??my_print_1:
   \   00000022   018C               MOVW    R17:R16, R25:R24
   \   00000024   ....               RCALL   hexadecimalTransmit
    160                break;
   \   00000026   C005               RJMP    ??my_print_4
    161          
    162          
    163              case DOUBLE:
    164                // Se transmite un număr double
    165                doubleTransmit(val);
   \                     ??my_print_2:
   \   00000028   018C               MOVW    R17:R16, R25:R24
   \   0000002A   ....               RCALL   doubleTransmit
    166                break;
   \   0000002C   C002               RJMP    ??my_print_4
    167              case CHAR:
    168                // Se transmite un caracter
    169                characterTransmit(val);
   \                     ??my_print_3:
   \   0000002E   018C               MOVW    R17:R16, R25:R24
   \   00000030   ....               RCALL   characterTransmit
    170                break;
    171            }
    172          }
   \                     ??my_print_4:
   \   00000032   E0E3               LDI     R30, 3
   \   00000034   ........           JMP     ?EPILOGUE_B3_L09

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      5      2   characterTransmit
        5      2   -> USART_transmit_string
     18      2   doubleTransmit
       18      2   -> USART_transmit_string
       18      2 ?F2SL_L04
       18      2 ?F_ADD_L04
       18      2 ?F_CMP_LT_L04
       18      2 ?F_MUL_L04
       18      2 ?F_SUB_L04
       18      2 ?SL2F_L04
       18      2 ?SS_DIVMOD_L02
      8      2   hexadecimalTransmit
        8      2   -> USART_transmit_string
        8      2 ?SS_SHR_L02
      8      2   integerTransmit
        8      2   -> USART_transmit_string
        8      2 ?SS_DIVMOD_L02
        8      2 ?S_EC_MUL_L02
      3      2   my_print
        3      2   -> characterTransmit
        3      2   -> doubleTransmit
        3      2   -> hexadecimalTransmit
        3      2   -> integerTransmit


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  aux1
      10  aux2
      38  characterTransmit
     436  doubleTransmit
     152  hexadecimalTransmit
     170  integerTransmit
      56  my_print
       7  -- Other

 
 852 bytes in segment CODE
   7 bytes in segment INITTAB
  20 bytes in segment NEAR_Z
 
 852 bytes of CODE memory (+ 7 bytes shared)
  20 bytes of DATA memory

Errors: none
Warnings: none
