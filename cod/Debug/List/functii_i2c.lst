###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       15/Jan/2026  21:39:59
# Copyright 1996-2022 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\functii_i2c.c
#    Command line =  
#        -f C:\Users\vboxuser\AppData\Local\Temp\EW172A.tmp
#        (C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\functii_i2c.c
#        --cpu=m1280 -ms -o
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\Obj -lC
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -lA
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List\functii_i2c.lst
#    Object file  =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\Obj\functii_i2c.r90
#
###############################################################################

C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\functii_i2c.c
      1          #include "functii_i2c.h"
      2          #include <ioavr.h>

   \                                 In  segment ABSOLUTE, at 0xbc
   \   union <unnamed> volatile __io _A_TWCR
   \                     _A_TWCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xbb
   \   union <unnamed> volatile __io _A_TWDR
   \                     _A_TWDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb9
   \   union <unnamed> volatile __io _A_TWSR
   \                     _A_TWSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb8
   \   union <unnamed> volatile __io _A_TWBR
   \                     _A_TWBR:
   \   00000000                      DS8 1
      3          #include <inavr.h>
      4          
      5          // Conditie START transmisa
      6          #define TW_START 0x08
      7          // Master Transmit: adresa + W transmisa, ACK primit
      8          #define TW_MT_SLA_ACK 0x18
      9          // Master Transmit: octet de date transmis, ACK primit
     10          #define TW_MT_DATA_ACK 0x28
     11          // Master Receive: adresa + R transmisa, ACK primit
     12          #define TW_MR_SLA_ACK 0x40
     13          // Master Receive: octet de date recep?ionat, ACK returnat
     14          #define TW_MR_DATA_ACK 0x50
     15          // Master Receive: octet de date recep?ionat, NACK returnat
     16          #define TW_MR_DATA_NACK 0x58 
     17          
     18          /*
     19          * Reprezinta starea curenta a modulului I2C/TWI.
     20          * Utilizata pentru a coordona transferurile non-blocante.
     21          */
     22          typedef enum {
     23            I2C_STATE_IDLE, // Nicio tranzactie în desfasurare
     24            I2C_STATE_WRITING, // Se efectueaza o tranzactie de scriere
     25            I2C_STATE_READING // Se efectueaza o tranzactie de citire
     26          } i2c_state_t;
     27          
     28          
     29          // Starea curenta

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     30          static volatile i2c_state_t g_i2c_state = I2C_STATE_IDLE;
   \                     g_i2c_state:
   \   00000000                      DS8 1
     31          // Ultimul status returnat

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     32          static volatile i2c_status_t g_i2c_status = I2C_STATUS_SUCCESS;
   \                     g_i2c_status:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     33          static uint8_t g_slave_address; // Adresa slave (cu bitul R/W inclus)
   \                     g_slave_address:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     34          static uint8_t* g_data_ptr; // Pointer catre bufferul de date
   \                     g_data_ptr:
   \   00000000                      DS8 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     35          static uint8_t g_data_len; // Lungimea totala a transferului
   \                     g_data_len:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     36          static uint8_t g_data_idx; // Indexul curent în buffer
   \                     g_data_idx:
   \   00000000                      DS8 1
     37          
     38          
     39          /*
     40          * Functia initializeaza modulul TWI/I2C.
     41          * - Configureaza prescaler-ul si frecven?a de lucru (SCL_CLOCK).
     42          * - Activeaza perifericul TWI (fara a activa întreruperile înca).
     43          */

   \                                 In  segment CODE, align 2, keep-with-next
     44          void i2c_init(void) {
   \                     i2c_init:
     45            TWSR = 0x00; // Prescaler = 1
   \   00000000   E000               LDI     R16, 0
   \   00000002   9300....           STS     _A_TWSR, R16
     46            // Baud-rate generator pentru SCL
     47            TWBR = ((F_CPU / SCL_CLOCK) - 16) / 2;
   \   00000006   E408               LDI     R16, 72
   \   00000008   9300....           STS     _A_TWBR, R16
     48            // Activeaza TWI, fara întreruperi
     49            TWCR = (1 << TWEN);
   \   0000000C   E004               LDI     R16, 4
   \   0000000E   9300....           STS     _A_TWCR, R16
     50          }
   \   00000012   9508               RET
   \   00000014                      REQUIRE _A_TWSR
   \   00000014                      REQUIRE _A_TWBR
   \   00000014                      REQUIRE _A_TWCR
     51          
     52          /*
     53          * Func?ia verifica daca magistrala I2C este ocupata.
     54          * Returneaza:
     55          * - 1 daca o tranzac?ie este în desfa?urare
     56          * - 0 daca modulul este inactiv (IDLE)
     57          */

   \                                 In  segment CODE, align 2, keep-with-next
     58          uint8_t i2c_is_busy(void) {
   \                     i2c_is_busy:
     59            return (g_i2c_state != I2C_STATE_IDLE);
   \   00000000   9100....           LDS     R16, g_i2c_state
   \   00000004   2300               TST     R16
   \   00000006   F011               BREQ    ??i2c_is_busy_0
   \   00000008   E001               LDI     R16, 1
   \   0000000A   9508               RET
   \                     ??i2c_is_busy_0:
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   9508               RET
     60          }
     61          
     62          
     63          /*
     64          * Functia returneaza ultimul status înregistrat al tranzac?iei.
     65          * Poate fi folosita pentru depanare.
     66          */

   \                                 In  segment CODE, align 2, keep-with-next
     67          i2c_status_t i2c_get_last_status(void) {
   \                     i2c_get_last_status:
     68            return g_i2c_status;
   \   00000000   9100....           LDS     R16, g_i2c_status
   \   00000004   9508               RET
     69          }
     70          
     71          
     72          /*
     73          * Func?ia porne?te o tranzactie de scriere NON-BLOCANTA.
     74          * Returneaza:
     75          * - I2C_STATUS_SUCCESS daca tranzactia a fost pornita
     76          * - I2C_STATUS_BUSY daca magistrala era deja ocupata
     77          */

   \                                 In  segment CODE, align 2, keep-with-next
     78          i2c_status_t i2c_write_transaction(uint8_t address, uint8_t* data, uint8_t length) {
   \                     i2c_write_transaction:
   \   00000000   2F40               MOV     R20, R16
     79            if (g_i2c_state != I2C_STATE_IDLE) {
   \   00000002   9100....           LDS     R16, g_i2c_state
   \   00000006   2300               TST     R16
   \   00000008   F011               BREQ    ??i2c_write_transaction_0
     80              return I2C_STATUS_BUSY;
   \   0000000A   E001               LDI     R16, 1
   \   0000000C   9508               RET
     81            }
     82            g_i2c_state = I2C_STATE_WRITING;
   \                     ??i2c_write_transaction_0:
   \   0000000E   E001               LDI     R16, 1
   \   00000010   9300....           STS     g_i2c_state, R16
     83            g_i2c_status = I2C_STATUS_BUSY;
   \   00000014   E001               LDI     R16, 1
   \   00000016   9300....           STS     g_i2c_status, R16
     84            g_slave_address = (address << 1) | TW_WRITE; // Adresa + bit W
   \   0000001A   2F04               MOV     R16, R20
   \   0000001C   0F00               LSL     R16
   \   0000001E   9300....           STS     g_slave_address, R16
     85            g_data_ptr = data;
   \   00000022   ....               LDI     R30, LOW(g_data_ptr)
   \   00000024   ....               LDI     R31, (g_data_ptr) >> 8
   \   00000026   8320               ST      Z, R18
   \   00000028   8331               STD     Z+1, R19
     86            g_data_len = length;
   \   0000002A   9310....           STS     g_data_len, R17
     87            g_data_idx = 0;
   \   0000002E   E000               LDI     R16, 0
   \   00000030   9300....           STS     g_data_idx, R16
     88            // Lansam tranzactia prin generarea condi?iei START + întrerupere
     89            TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWIE);
   \   00000034   EA05               LDI     R16, 165
   \   00000036   9300....           STS     _A_TWCR, R16
     90            
     91            return I2C_STATUS_SUCCESS;
   \   0000003A   E000               LDI     R16, 0
   \   0000003C   9508               RET
   \   0000003E                      REQUIRE _A_TWCR
     92          }
     93          
     94          /*
     95          * Func?ia porne?te o tranzac?ie de citire NON-BLOCANTA.
     96          * Returneaza:
     97          * - I2C_STATUS_SUCCESS daca tranzac?ia a fost pornita
     98          * - I2C_STATUS_BUSY daca magistrala era deja ocupata
     99          */

   \                                 In  segment CODE, align 2, keep-with-next
    100          i2c_status_t i2c_read_transaction(uint8_t address, uint8_t* data, uint8_t length) {
   \                     i2c_read_transaction:
   \   00000000   2F40               MOV     R20, R16
    101            if (g_i2c_state != I2C_STATE_IDLE) {
   \   00000002   9100....           LDS     R16, g_i2c_state
   \   00000006   2300               TST     R16
   \   00000008   F011               BREQ    ??i2c_read_transaction_0
    102              return I2C_STATUS_BUSY; // Magistrala e ocupata
   \   0000000A   E001               LDI     R16, 1
   \   0000000C   9508               RET
    103            }
    104            g_i2c_state = I2C_STATE_READING;
   \                     ??i2c_read_transaction_0:
   \   0000000E   E002               LDI     R16, 2
   \   00000010   9300....           STS     g_i2c_state, R16
    105            g_i2c_status = I2C_STATUS_BUSY;
   \   00000014   E001               LDI     R16, 1
   \   00000016   9300....           STS     g_i2c_status, R16
    106            g_slave_address = (address << 1) | 1; // Adresa + bit R
   \   0000001A   2F04               MOV     R16, R20
   \   0000001C   0F00               LSL     R16
   \   0000001E   6001               ORI     R16, 0x01
   \   00000020   9300....           STS     g_slave_address, R16
    107            g_data_ptr = data;
   \   00000024   ....               LDI     R30, LOW(g_data_ptr)
   \   00000026   ....               LDI     R31, (g_data_ptr) >> 8
   \   00000028   8320               ST      Z, R18
   \   0000002A   8331               STD     Z+1, R19
    108            g_data_len = length;
   \   0000002C   9310....           STS     g_data_len, R17
    109            g_data_idx = 0;
   \   00000030   E000               LDI     R16, 0
   \   00000032   9300....           STS     g_data_idx, R16
    110            // Pentru citire, ini?iem cu un START
    111            TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWIE);
   \   00000036   EA05               LDI     R16, 165
   \   00000038   9300....           STS     _A_TWCR, R16
    112            return I2C_STATUS_SUCCESS;
   \   0000003C   E000               LDI     R16, 0
   \   0000003E   9508               RET
   \   00000040                      REQUIRE _A_TWCR
    113          }
    114          
    115          /*
    116          * Aceasta rutina implementeaza logica ma?inii de stari pentru TWI/I2C.
    117          * Gestioneaza atât opera?iile de scriere, cât ?i pe cele de citire,
    118          * pe baza valorii registrului TWSR (status).
    119          */
    120          #pragma vector = TWI_vect

   \                                 In  segment CODE, align 2, keep-with-next
    121          __interrupt void TWI_ISR(void) {
   \                     TWI_ISR:
   \   00000000   93FA               ST      -Y, R31
   \   00000002   93EA               ST      -Y, R30
   \   00000004   934A               ST      -Y, R20
   \   00000006   933A               ST      -Y, R19
   \   00000008   932A               ST      -Y, R18
   \   0000000A   931A               ST      -Y, R17
   \   0000000C   930A               ST      -Y, R16
   \   0000000E   B73F               IN      R19, 0x3F
   \   00000010   B74B               IN      R20, 0x3B
    122            switch (TWSR & 0xF8) { // Se mascheaza doar bi?ii de status
   \   00000012   9100....           LDS     R16, _A_TWSR
   \   00000016   E010               LDI     R17, 0
   \   00000018   7F08               ANDI    R16, 0xF8
   \   0000001A   7010               ANDI    R17, 0x00
   \   0000001C   5008               SUBI    R16, 8
   \   0000001E   F069               BREQ    ??TWI_ISR_0
   \   00000020   5100               SUBI    R16, 16
   \   00000022   F099               BREQ    ??TWI_ISR_1
   \   00000024   5100               SUBI    R16, 16
   \   00000026   F089               BREQ    ??TWI_ISR_1
   \   00000028   5108               SUBI    R16, 24
   \   0000002A   F1A1               BREQ    ??TWI_ISR_2
   \   0000002C   5100               SUBI    R16, 16
   \   0000002E   F409               BRNE    $+2+2
   \   00000030   C043               RJMP    ??TWI_ISR_3
   \   00000032   5008               SUBI    R16, 8
   \   00000034   F409               BRNE    $+2+2
   \   00000036   C063               RJMP    ??TWI_ISR_4
   \   00000038   C07D               RJMP    ??TWI_ISR_5
    123            case TW_START: // Condi?ie START trimisa
    124              TWDR = g_slave_address; // Se trimite adresa + bit R/W
   \                     ??TWI_ISR_0:
   \   0000003A   9100....           LDS     R16, g_slave_address
   \   0000003E   9300....           STS     _A_TWDR, R16
    125              TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
   \   00000042   E805               LDI     R16, 133
   \   00000044   9300....           STS     _A_TWCR, R16
    126              break;
   \   00000048   C07E               RJMP    ??TWI_ISR_6
    127              // Slave a raspuns cu ACK dupa adresa
    128            case TW_MT_SLA_ACK:
    129              // Slave a raspuns cu ACK dupa un octet de date
    130            case TW_MT_DATA_ACK:
    131              if (g_data_idx < g_data_len) {
   \                     ??TWI_ISR_1:
   \   0000004A   9100....           LDS     R16, g_data_idx
   \   0000004E   9110....           LDS     R17, g_data_len
   \   00000052   1701               CP      R16, R17
   \   00000054   F4A8               BRCC    ??TWI_ISR_7
    132                // Mai sunt date de transmis
    133                TWDR = g_data_ptr[g_data_idx++];
   \   00000056   9100....           LDS     R16, g_data_idx
   \   0000005A   E010               LDI     R17, 0
   \   0000005C   91E0....           LDS     R30, g_data_ptr
   \   00000060   91F0....           LDS     R31, (g_data_ptr + 1)
   \   00000064   0FE0               ADD     R30, R16
   \   00000066   1FF1               ADC     R31, R17
   \   00000068   8100               LD      R16, Z
   \   0000006A   9300....           STS     _A_TWDR, R16
   \   0000006E   9100....           LDS     R16, g_data_idx
   \   00000072   9503               INC     R16
   \   00000074   9300....           STS     g_data_idx, R16
    134                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
   \   00000078   E805               LDI     R16, 133
   \   0000007A   9300....           STS     _A_TWCR, R16
   \   0000007E   C063               RJMP    ??TWI_ISR_6
    135              } else {
    136                // S-a terminat transmisia
    137                TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
   \                     ??TWI_ISR_7:
   \   00000080   E904               LDI     R16, 148
   \   00000082   9300....           STS     _A_TWCR, R16
    138                g_i2c_status = I2C_STATUS_SUCCESS;
   \   00000086   E000               LDI     R16, 0
   \   00000088   9300....           STS     g_i2c_status, R16
    139                g_i2c_state = I2C_STATE_IDLE;
   \   0000008C   E000               LDI     R16, 0
   \   0000008E   9300....           STS     g_i2c_state, R16
    140              }
    141              break;
   \   00000092   C059               RJMP    ??TWI_ISR_6
    142              // S-a trimis adresa + R, Slave a raspuns cu ACK
    143            case TW_MR_SLA_ACK:
    144              // Daca mai este mai mult de 1 octet de citit e returnat ACK
    145              if (g_data_len - g_data_idx > 1) {
   \                     ??TWI_ISR_2:
   \   00000094   91E0....           LDS     R30, g_data_len
   \   00000098   E0F0               LDI     R31, 0
   \   0000009A   9100....           LDS     R16, g_data_idx
   \   0000009E   E010               LDI     R17, 0
   \   000000A0   1BE0               SUB     R30, R16
   \   000000A2   0BF1               SBC     R31, R17
   \   000000A4   9732               SBIW    R31:R30, 2
   \   000000A6   F024               BRLT    ??TWI_ISR_8
    146                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE) | (1 << TWEA);
   \   000000A8   EC05               LDI     R16, 197
   \   000000AA   9300....           STS     _A_TWCR, R16
   \   000000AE   C04B               RJMP    ??TWI_ISR_6
    147              } else {
    148                // Ultimul octet, deci se returneaza NACK
    149                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
   \                     ??TWI_ISR_8:
   \   000000B0   E805               LDI     R16, 133
   \   000000B2   9300....           STS     _A_TWCR, R16
    150              }
    151              break;
   \   000000B6   C047               RJMP    ??TWI_ISR_6
    152            case TW_MR_DATA_ACK: // S-a citit un octet ?i s-a trimis ACK
    153              g_data_ptr[g_data_idx++] = TWDR;
   \                     ??TWI_ISR_3:
   \   000000B8   9120....           LDS     R18, _A_TWDR
   \   000000BC   9100....           LDS     R16, g_data_idx
   \   000000C0   E010               LDI     R17, 0
   \   000000C2   91E0....           LDS     R30, g_data_ptr
   \   000000C6   91F0....           LDS     R31, (g_data_ptr + 1)
   \   000000CA   0FE0               ADD     R30, R16
   \   000000CC   1FF1               ADC     R31, R17
   \   000000CE   8320               ST      Z, R18
   \   000000D0   9100....           LDS     R16, g_data_idx
   \   000000D4   9503               INC     R16
   \   000000D6   9300....           STS     g_data_idx, R16
    154              if (g_data_len - g_data_idx > 1) {
   \   000000DA   91E0....           LDS     R30, g_data_len
   \   000000DE   E0F0               LDI     R31, 0
   \   000000E0   9100....           LDS     R16, g_data_idx
   \   000000E4   E010               LDI     R17, 0
   \   000000E6   1BE0               SUB     R30, R16
   \   000000E8   0BF1               SBC     R31, R17
   \   000000EA   9732               SBIW    R31:R30, 2
   \   000000EC   F024               BRLT    ??TWI_ISR_9
    155                // Mai sunt date de citit, deci se cere cu ACK
    156                TWCR = (1 << TWINT)|(1 << TWEN)|(1 << TWIE) | (1 << TWEA);
   \   000000EE   EC05               LDI     R16, 197
   \   000000F0   9300....           STS     _A_TWCR, R16
   \   000000F4   C028               RJMP    ??TWI_ISR_6
    157              } else {
    158                // Urmeaza ultimul octet, deci se cere fara ACK
    159                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
   \                     ??TWI_ISR_9:
   \   000000F6   E805               LDI     R16, 133
   \   000000F8   9300....           STS     _A_TWCR, R16
    160              }
    161              break;
   \   000000FC   C024               RJMP    ??TWI_ISR_6
    162              // S-a citit ultimul octet ?i s-a trimis NACK
    163            case TW_MR_DATA_NACK:
    164              g_data_ptr[g_data_idx++] = TWDR;
   \                     ??TWI_ISR_4:
   \   000000FE   9120....           LDS     R18, _A_TWDR
   \   00000102   9100....           LDS     R16, g_data_idx
   \   00000106   E010               LDI     R17, 0
   \   00000108   91E0....           LDS     R30, g_data_ptr
   \   0000010C   91F0....           LDS     R31, (g_data_ptr + 1)
   \   00000110   0FE0               ADD     R30, R16
   \   00000112   1FF1               ADC     R31, R17
   \   00000114   8320               ST      Z, R18
   \   00000116   9100....           LDS     R16, g_data_idx
   \   0000011A   9503               INC     R16
   \   0000011C   9300....           STS     g_data_idx, R16
    165              TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN); // STOP
   \   00000120   E904               LDI     R16, 148
   \   00000122   9300....           STS     _A_TWCR, R16
    166              g_i2c_status = I2C_STATUS_SUCCESS;
   \   00000126   E000               LDI     R16, 0
   \   00000128   9300....           STS     g_i2c_status, R16
    167              g_i2c_state = I2C_STATE_IDLE;
   \   0000012C   E000               LDI     R16, 0
   \   0000012E   9300....           STS     g_i2c_state, R16
    168              break;
   \   00000132   C009               RJMP    ??TWI_ISR_6
    169            default:
    170              g_i2c_status = I2C_STATUS_ERROR; // Se semnaleaza eroarea
   \                     ??TWI_ISR_5:
   \   00000134   E002               LDI     R16, 2
   \   00000136   9300....           STS     g_i2c_status, R16
    171              // STOP – se elibereaza magistrala
    172              TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
   \   0000013A   E904               LDI     R16, 148
   \   0000013C   9300....           STS     _A_TWCR, R16
    173              g_i2c_state = I2C_STATE_IDLE;
   \   00000140   E000               LDI     R16, 0
   \   00000142   9300....           STS     g_i2c_state, R16
    174              break;
    175            }
    176          }
   \                     ??TWI_ISR_6:
   \   00000146   BF4B               OUT     0x3B, R20
   \   00000148   BF3F               OUT     0x3F, R19
   \   0000014A   9109               LD      R16, Y+
   \   0000014C   9119               LD      R17, Y+
   \   0000014E   9129               LD      R18, Y+
   \   00000150   9139               LD      R19, Y+
   \   00000152   9149               LD      R20, Y+
   \   00000154   91E9               LD      R30, Y+
   \   00000156   91F9               LD      R31, Y+
   \   00000158   9518               RETI
   \   0000015A                      REQUIRE _A_TWDR
   \   0000015A                      REQUIRE _A_TWCR
   \   0000015A                      REQUIRE _A_TWSR

   \                                 In  segment INTVEC, offset 0x9c, root
   \                     `??TWI_ISR::??INTVEC 156`:
   \   0000009C   ........           JMP     TWI_ISR

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      7      2   TWI_ISR
      0      2   i2c_get_last_status
      0      2   i2c_init
      0      2   i2c_is_busy
      0      2   i2c_read_transaction
      0      2   i2c_write_transaction


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     346  TWI_ISR
       4  TWI_ISR::??INTVEC 156
       1  _A_TWBR
       1  _A_TWCR
       1  _A_TWDR
       1  _A_TWSR
       1  g_data_idx
       1  g_data_len
       2  g_data_ptr
       1  g_i2c_state
       1  g_i2c_status
       1  g_slave_address
       6  i2c_get_last_status
      20  i2c_init
      16  i2c_is_busy
      64  i2c_read_transaction
      62  i2c_write_transaction
       7  -- Other

 
   4 bytes in segment ABSOLUTE
 514 bytes in segment CODE
   7 bytes in segment INITTAB
   4 bytes in segment INTVEC
   7 bytes in segment NEAR_Z
 
 514 bytes of CODE memory (+ 11 bytes shared)
   7 bytes of DATA memory (+  4 bytes shared)

Errors: none
Warnings: none
