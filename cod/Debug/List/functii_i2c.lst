###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       18/Jan/2026  12:23:17
# Copyright 1996-2022 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\functii_i2c.c
#    Command line =  
#        -f C:\Users\student\AppData\Local\Temp\EWF746.tmp
#        (C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\functii_i2c.c
#        --cpu=m1280 -ms -o
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\Obj
#        -lC
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\List
#        -lA
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\List
#        -y --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\List\functii_i2c.lst
#    Object file  =  
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\Obj\functii_i2c.r90
#
###############################################################################

C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\functii_i2c.c
      1          #include "functii_i2c.h"
      2          #include <ioavr.h>

   \                                 In  segment ABSOLUTE, at 0xbc
   \   union <unnamed> volatile __io _A_TWCR
   \                     _A_TWCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xbb
   \   union <unnamed> volatile __io _A_TWDR
   \                     _A_TWDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb9
   \   union <unnamed> volatile __io _A_TWSR
   \                     _A_TWSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb8
   \   union <unnamed> volatile __io _A_TWBR
   \                     _A_TWBR:
   \   00000000                      DS8 1
      3          #include <inavr.h>
      4          #include <stdint.h>
      5          
      6          // Conditie START transmisa
      7          #define TW_START 0x08
      8          // Master Transmit: adresa + W transmisa, ACK primit
      9          #define TW_MT_SLA_ACK 0x18
     10          // Master Transmit: octet de date transmis, ACK primit
     11          #define TW_MT_DATA_ACK 0x28
     12          // Master Receive: adresa + R transmisa, ACK primit
     13          #define TW_MR_SLA_ACK 0x40
     14          // Master Receive: octet de date recep?ionat, ACK returnat
     15          #define TW_MR_DATA_ACK 0x50
     16          // Master Receive: octet de date recep?ionat, NACK returnat
     17          #define TW_MR_DATA_NACK 0x58 
     18          
     19          
     20          // Starea curenta

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     21          volatile i2c_state_t g_i2c_state = I2C_STATE_IDLE;
   \                     g_i2c_state:
   \   00000000                      DS8 1
     22          // Ultimul status returnat

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     23          static volatile i2c_status_t g_i2c_status = I2C_STATUS_SUCCESS;
   \                     g_i2c_status:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     24          static uint8_t g_slave_address; // Adresa slave (cu bitul R/W inclus)
   \                     g_slave_address:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     25          static uint8_t* g_data_ptr; // Pointer catre bufferul de date
   \                     g_data_ptr:
   \   00000000                      DS8 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     26          static uint8_t g_data_len; // Lungimea totala a transferului
   \                     g_data_len:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     27          static uint8_t g_data_idx; // Indexul curent în buffer
   \                     g_data_idx:
   \   00000000                      DS8 1
     28          
     29          /*
     30          * Functia initializeaza modulul TWI/I2C.
     31          * - Configureaza prescaler-ul si frecven?a de lucru (SCL_CLOCK).
     32          * - Activeaza perifericul TWI (fara a activa întreruperile înca).
     33          */

   \                                 In  segment CODE, align 2, keep-with-next
     34          void i2c_init(void) {
   \                     i2c_init:
     35            TWSR = 0x00; // Prescaler = 1
   \   00000000   E000               LDI     R16, 0
   \   00000002   9300....           STS     _A_TWSR, R16
     36            // Baud-rate generator pentru SCL
     37            TWBR = ((F_CPU / SCL_CLOCK) - 16) / 2;
   \   00000006   E408               LDI     R16, 72
   \   00000008   9300....           STS     _A_TWBR, R16
     38            // Activeaza TWI, fara întreruperi
     39            TWCR = (1 << TWEN);
   \   0000000C   E004               LDI     R16, 4
   \   0000000E   9300....           STS     _A_TWCR, R16
     40          }
   \   00000012   9508               RET
   \   00000014                      REQUIRE _A_TWSR
   \   00000014                      REQUIRE _A_TWBR
   \   00000014                      REQUIRE _A_TWCR
     41          
     42          /*
     43          * Func?ia verifica daca magistrala I2C este ocupata.
     44          * Returneaza:
     45          * - 1 daca o tranzac?ie este în desfa?urare
     46          * - 0 daca modulul este inactiv (IDLE)
     47          */

   \                                 In  segment CODE, align 2, keep-with-next
     48          uint8_t i2c_is_busy(void) {
   \                     i2c_is_busy:
     49            return (g_i2c_state != I2C_STATE_IDLE);
   \   00000000   9100....           LDS     R16, g_i2c_state
   \   00000004   2300               TST     R16
   \   00000006   F011               BREQ    ??i2c_is_busy_0
   \   00000008   E001               LDI     R16, 1
   \   0000000A   9508               RET
   \                     ??i2c_is_busy_0:
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   9508               RET
     50          }
     51          
     52          
     53          /*
     54          * Functia returneaza ultimul status înregistrat al tranzac?iei.
     55          * Poate fi folosita pentru depanare.
     56          */

   \                                 In  segment CODE, align 2, keep-with-next
     57          i2c_status_t i2c_get_last_status(void) {
   \                     i2c_get_last_status:
     58            return g_i2c_status;
   \   00000000   9100....           LDS     R16, g_i2c_status
   \   00000004   9508               RET
     59          }
     60          
     61          
     62          /*
     63          * Func?ia porne?te o tranzactie de scriere NON-BLOCANTA.
     64          * Returneaza:
     65          * - I2C_STATUS_SUCCESS daca tranzactia a fost pornita
     66          * - I2C_STATUS_BUSY daca magistrala era deja ocupata
     67          */

   \                                 In  segment CODE, align 2, keep-with-next
     68          i2c_status_t i2c_write_transaction(uint8_t address, uint8_t* data, uint8_t length) {
   \                     i2c_write_transaction:
   \   00000000   2F40               MOV     R20, R16
     69            if (g_i2c_state != I2C_STATE_IDLE) {
   \   00000002   9100....           LDS     R16, g_i2c_state
   \   00000006   2300               TST     R16
   \   00000008   F011               BREQ    ??i2c_write_transaction_0
     70              return I2C_STATUS_BUSY;
   \   0000000A   E001               LDI     R16, 1
   \   0000000C   9508               RET
     71            }
     72            g_i2c_state = I2C_STATE_WRITING;
   \                     ??i2c_write_transaction_0:
   \   0000000E   E001               LDI     R16, 1
   \   00000010   9300....           STS     g_i2c_state, R16
     73            g_i2c_status = I2C_STATUS_BUSY;
   \   00000014   E001               LDI     R16, 1
   \   00000016   9300....           STS     g_i2c_status, R16
     74            g_slave_address = (address << 1) | TW_WRITE; // Adresa + bit W
   \   0000001A   2F04               MOV     R16, R20
   \   0000001C   0F00               LSL     R16
   \   0000001E   9300....           STS     g_slave_address, R16
     75            g_data_ptr = data;
   \   00000022   ....               LDI     R30, LOW(g_data_ptr)
   \   00000024   ....               LDI     R31, (g_data_ptr) >> 8
   \   00000026   8320               ST      Z, R18
   \   00000028   8331               STD     Z+1, R19
     76            g_data_len = length;
   \   0000002A   9310....           STS     g_data_len, R17
     77            g_data_idx = 0;
   \   0000002E   E000               LDI     R16, 0
   \   00000030   9300....           STS     g_data_idx, R16
     78            // Lansam tranzactia prin generarea condi?iei START + întrerupere
     79            TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWIE);
   \   00000034   EA05               LDI     R16, 165
   \   00000036   9300....           STS     _A_TWCR, R16
     80            
     81            return I2C_STATUS_SUCCESS;
   \   0000003A   E000               LDI     R16, 0
   \   0000003C   9508               RET
   \   0000003E                      REQUIRE _A_TWCR
     82          }
     83          
     84          /*
     85          * Func?ia porne?te o tranzac?ie de citire NON-BLOCANTA.
     86          * Returneaza:
     87          * - I2C_STATUS_SUCCESS daca tranzac?ia a fost pornita
     88          * - I2C_STATUS_BUSY daca magistrala era deja ocupata
     89          */

   \                                 In  segment CODE, align 2, keep-with-next
     90          i2c_status_t i2c_read_transaction(uint8_t address, uint8_t* data, uint8_t length) {
   \                     i2c_read_transaction:
   \   00000000   2F40               MOV     R20, R16
     91            if (g_i2c_state != I2C_STATE_IDLE) {
   \   00000002   9100....           LDS     R16, g_i2c_state
   \   00000006   2300               TST     R16
   \   00000008   F011               BREQ    ??i2c_read_transaction_0
     92              return I2C_STATUS_BUSY; // Magistrala e ocupata
   \   0000000A   E001               LDI     R16, 1
   \   0000000C   9508               RET
     93            }
     94            g_i2c_state = I2C_STATE_READING;
   \                     ??i2c_read_transaction_0:
   \   0000000E   E002               LDI     R16, 2
   \   00000010   9300....           STS     g_i2c_state, R16
     95            g_i2c_status = I2C_STATUS_BUSY;
   \   00000014   E001               LDI     R16, 1
   \   00000016   9300....           STS     g_i2c_status, R16
     96            g_slave_address = (address << 1) | 1; // Adresa + bit R
   \   0000001A   2F04               MOV     R16, R20
   \   0000001C   0F00               LSL     R16
   \   0000001E   6001               ORI     R16, 0x01
   \   00000020   9300....           STS     g_slave_address, R16
     97            g_data_ptr = data;
   \   00000024   ....               LDI     R30, LOW(g_data_ptr)
   \   00000026   ....               LDI     R31, (g_data_ptr) >> 8
   \   00000028   8320               ST      Z, R18
   \   0000002A   8331               STD     Z+1, R19
     98            g_data_len = length;
   \   0000002C   9310....           STS     g_data_len, R17
     99            g_data_idx = 0;
   \   00000030   E000               LDI     R16, 0
   \   00000032   9300....           STS     g_data_idx, R16
    100            // Pentru citire, ini?iem cu un START
    101            TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWIE);
   \   00000036   EA05               LDI     R16, 165
   \   00000038   9300....           STS     _A_TWCR, R16
    102            return I2C_STATUS_SUCCESS;
   \   0000003C   E000               LDI     R16, 0
   \   0000003E   9508               RET
   \   00000040                      REQUIRE _A_TWCR
    103          }
    104          
    105          /*
    106          * Aceasta rutina implementeaza logica ma?inii de stari pentru TWI/I2C.
    107          * Gestioneaza atât opera?iile de scriere, cât ?i pe cele de citire,
    108          * pe baza valorii registrului TWSR (status).
    109          */
    110          #pragma vector = TWI_vect

   \                                 In  segment CODE, align 2, keep-with-next
    111          __interrupt void TWI_ISR(void) {
   \                     TWI_ISR:
   \   00000000   93FA               ST      -Y, R31
   \   00000002   93EA               ST      -Y, R30
   \   00000004   934A               ST      -Y, R20
   \   00000006   933A               ST      -Y, R19
   \   00000008   932A               ST      -Y, R18
   \   0000000A   931A               ST      -Y, R17
   \   0000000C   930A               ST      -Y, R16
   \   0000000E   B73F               IN      R19, 0x3F
   \   00000010   B74B               IN      R20, 0x3B
    112            switch (TWSR & 0xF8) { // Se mascheaza doar bi?ii de status
   \   00000012   9100....           LDS     R16, _A_TWSR
   \   00000016   E010               LDI     R17, 0
   \   00000018   7F08               ANDI    R16, 0xF8
   \   0000001A   7010               ANDI    R17, 0x00
   \   0000001C   5008               SUBI    R16, 8
   \   0000001E   F069               BREQ    ??TWI_ISR_0
   \   00000020   5100               SUBI    R16, 16
   \   00000022   F099               BREQ    ??TWI_ISR_1
   \   00000024   5100               SUBI    R16, 16
   \   00000026   F089               BREQ    ??TWI_ISR_1
   \   00000028   5108               SUBI    R16, 24
   \   0000002A   F1A1               BREQ    ??TWI_ISR_2
   \   0000002C   5100               SUBI    R16, 16
   \   0000002E   F409               BRNE    $+2+2
   \   00000030   C043               RJMP    ??TWI_ISR_3
   \   00000032   5008               SUBI    R16, 8
   \   00000034   F409               BRNE    $+2+2
   \   00000036   C063               RJMP    ??TWI_ISR_4
   \   00000038   C07D               RJMP    ??TWI_ISR_5
    113            case TW_START: // Condi?ie START trimisa
    114              TWDR = g_slave_address; // Se trimite adresa + bit R/W
   \                     ??TWI_ISR_0:
   \   0000003A   9100....           LDS     R16, g_slave_address
   \   0000003E   9300....           STS     _A_TWDR, R16
    115              TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
   \   00000042   E805               LDI     R16, 133
   \   00000044   9300....           STS     _A_TWCR, R16
    116              break;
   \   00000048   C07E               RJMP    ??TWI_ISR_6
    117              // Slave a raspuns cu ACK dupa adresa
    118            case TW_MT_SLA_ACK:
    119              // Slave a raspuns cu ACK dupa un octet de date
    120            case TW_MT_DATA_ACK:
    121              if (g_data_idx < g_data_len) {
   \                     ??TWI_ISR_1:
   \   0000004A   9100....           LDS     R16, g_data_idx
   \   0000004E   9110....           LDS     R17, g_data_len
   \   00000052   1701               CP      R16, R17
   \   00000054   F4A8               BRCC    ??TWI_ISR_7
    122                // Mai sunt date de transmis
    123                TWDR = g_data_ptr[g_data_idx++];
   \   00000056   9100....           LDS     R16, g_data_idx
   \   0000005A   E010               LDI     R17, 0
   \   0000005C   91E0....           LDS     R30, g_data_ptr
   \   00000060   91F0....           LDS     R31, (g_data_ptr + 1)
   \   00000064   0FE0               ADD     R30, R16
   \   00000066   1FF1               ADC     R31, R17
   \   00000068   8100               LD      R16, Z
   \   0000006A   9300....           STS     _A_TWDR, R16
   \   0000006E   9100....           LDS     R16, g_data_idx
   \   00000072   9503               INC     R16
   \   00000074   9300....           STS     g_data_idx, R16
    124                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
   \   00000078   E805               LDI     R16, 133
   \   0000007A   9300....           STS     _A_TWCR, R16
   \   0000007E   C063               RJMP    ??TWI_ISR_6
    125              } else {
    126                // S-a terminat transmisia
    127                TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
   \                     ??TWI_ISR_7:
   \   00000080   E904               LDI     R16, 148
   \   00000082   9300....           STS     _A_TWCR, R16
    128                g_i2c_status = I2C_STATUS_SUCCESS;
   \   00000086   E000               LDI     R16, 0
   \   00000088   9300....           STS     g_i2c_status, R16
    129                g_i2c_state = I2C_STATE_IDLE;
   \   0000008C   E000               LDI     R16, 0
   \   0000008E   9300....           STS     g_i2c_state, R16
    130              }
    131              break;
   \   00000092   C059               RJMP    ??TWI_ISR_6
    132              // S-a trimis adresa + R, Slave a raspuns cu ACK
    133            case TW_MR_SLA_ACK:
    134              // Daca mai este mai mult de 1 octet de citit e returnat ACK
    135              if (g_data_len - g_data_idx > 1) {
   \                     ??TWI_ISR_2:
   \   00000094   91E0....           LDS     R30, g_data_len
   \   00000098   E0F0               LDI     R31, 0
   \   0000009A   9100....           LDS     R16, g_data_idx
   \   0000009E   E010               LDI     R17, 0
   \   000000A0   1BE0               SUB     R30, R16
   \   000000A2   0BF1               SBC     R31, R17
   \   000000A4   9732               SBIW    R31:R30, 2
   \   000000A6   F024               BRLT    ??TWI_ISR_8
    136                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE) | (1 << TWEA);
   \   000000A8   EC05               LDI     R16, 197
   \   000000AA   9300....           STS     _A_TWCR, R16
   \   000000AE   C04B               RJMP    ??TWI_ISR_6
    137              } else {
    138                // Ultimul octet, deci se returneaza NACK
    139                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
   \                     ??TWI_ISR_8:
   \   000000B0   E805               LDI     R16, 133
   \   000000B2   9300....           STS     _A_TWCR, R16
    140              }
    141              break;
   \   000000B6   C047               RJMP    ??TWI_ISR_6
    142            case TW_MR_DATA_ACK: // S-a citit un octet ?i s-a trimis ACK
    143              g_data_ptr[g_data_idx++] = TWDR;
   \                     ??TWI_ISR_3:
   \   000000B8   9120....           LDS     R18, _A_TWDR
   \   000000BC   9100....           LDS     R16, g_data_idx
   \   000000C0   E010               LDI     R17, 0
   \   000000C2   91E0....           LDS     R30, g_data_ptr
   \   000000C6   91F0....           LDS     R31, (g_data_ptr + 1)
   \   000000CA   0FE0               ADD     R30, R16
   \   000000CC   1FF1               ADC     R31, R17
   \   000000CE   8320               ST      Z, R18
   \   000000D0   9100....           LDS     R16, g_data_idx
   \   000000D4   9503               INC     R16
   \   000000D6   9300....           STS     g_data_idx, R16
    144              if (g_data_len - g_data_idx > 1) {
   \   000000DA   91E0....           LDS     R30, g_data_len
   \   000000DE   E0F0               LDI     R31, 0
   \   000000E0   9100....           LDS     R16, g_data_idx
   \   000000E4   E010               LDI     R17, 0
   \   000000E6   1BE0               SUB     R30, R16
   \   000000E8   0BF1               SBC     R31, R17
   \   000000EA   9732               SBIW    R31:R30, 2
   \   000000EC   F024               BRLT    ??TWI_ISR_9
    145                // Mai sunt date de citit, deci se cere cu ACK
    146                TWCR = (1 << TWINT)|(1 << TWEN)|(1 << TWIE) | (1 << TWEA);
   \   000000EE   EC05               LDI     R16, 197
   \   000000F0   9300....           STS     _A_TWCR, R16
   \   000000F4   C028               RJMP    ??TWI_ISR_6
    147              } else {
    148                // Urmeaza ultimul octet, deci se cere fara ACK
    149                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
   \                     ??TWI_ISR_9:
   \   000000F6   E805               LDI     R16, 133
   \   000000F8   9300....           STS     _A_TWCR, R16
    150              }
    151              break;
   \   000000FC   C024               RJMP    ??TWI_ISR_6
    152              // S-a citit ultimul octet ?i s-a trimis NACK
    153            case TW_MR_DATA_NACK:
    154              g_data_ptr[g_data_idx++] = TWDR;
   \                     ??TWI_ISR_4:
   \   000000FE   9120....           LDS     R18, _A_TWDR
   \   00000102   9100....           LDS     R16, g_data_idx
   \   00000106   E010               LDI     R17, 0
   \   00000108   91E0....           LDS     R30, g_data_ptr
   \   0000010C   91F0....           LDS     R31, (g_data_ptr + 1)
   \   00000110   0FE0               ADD     R30, R16
   \   00000112   1FF1               ADC     R31, R17
   \   00000114   8320               ST      Z, R18
   \   00000116   9100....           LDS     R16, g_data_idx
   \   0000011A   9503               INC     R16
   \   0000011C   9300....           STS     g_data_idx, R16
    155              TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN); // STOP
   \   00000120   E904               LDI     R16, 148
   \   00000122   9300....           STS     _A_TWCR, R16
    156              g_i2c_status = I2C_STATUS_SUCCESS;
   \   00000126   E000               LDI     R16, 0
   \   00000128   9300....           STS     g_i2c_status, R16
    157              g_i2c_state = I2C_STATE_IDLE;
   \   0000012C   E000               LDI     R16, 0
   \   0000012E   9300....           STS     g_i2c_state, R16
    158              break;
   \   00000132   C009               RJMP    ??TWI_ISR_6
    159            default:
    160              g_i2c_status = I2C_STATUS_ERROR; // Se semnaleaza eroarea
   \                     ??TWI_ISR_5:
   \   00000134   E002               LDI     R16, 2
   \   00000136   9300....           STS     g_i2c_status, R16
    161              // STOP – se elibereaza magistrala
    162              TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
   \   0000013A   E904               LDI     R16, 148
   \   0000013C   9300....           STS     _A_TWCR, R16
    163              g_i2c_state = I2C_STATE_IDLE;
   \   00000140   E000               LDI     R16, 0
   \   00000142   9300....           STS     g_i2c_state, R16
    164              break;
    165            }
    166          }
   \                     ??TWI_ISR_6:
   \   00000146   BF4B               OUT     0x3B, R20
   \   00000148   BF3F               OUT     0x3F, R19
   \   0000014A   9109               LD      R16, Y+
   \   0000014C   9119               LD      R17, Y+
   \   0000014E   9129               LD      R18, Y+
   \   00000150   9139               LD      R19, Y+
   \   00000152   9149               LD      R20, Y+
   \   00000154   91E9               LD      R30, Y+
   \   00000156   91F9               LD      R31, Y+
   \   00000158   9518               RETI
   \   0000015A                      REQUIRE _A_TWDR
   \   0000015A                      REQUIRE _A_TWCR
   \   0000015A                      REQUIRE _A_TWSR

   \                                 In  segment INTVEC, offset 0x9c, root
   \                     `??TWI_ISR::??INTVEC 156`:
   \   0000009C   ........           JMP     TWI_ISR

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      7      2   TWI_ISR
      0      2   i2c_get_last_status
      0      2   i2c_init
      0      2   i2c_is_busy
      0      2   i2c_read_transaction
      0      2   i2c_write_transaction


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     346  TWI_ISR
       4  TWI_ISR::??INTVEC 156
       1  _A_TWBR
       1  _A_TWCR
       1  _A_TWDR
       1  _A_TWSR
       1  g_data_idx
       1  g_data_len
       2  g_data_ptr
       1  g_i2c_state
       1  g_i2c_status
       1  g_slave_address
       6  i2c_get_last_status
      20  i2c_init
      16  i2c_is_busy
      64  i2c_read_transaction
      62  i2c_write_transaction
       7  -- Other

 
   4 bytes in segment ABSOLUTE
 514 bytes in segment CODE
   7 bytes in segment INITTAB
   4 bytes in segment INTVEC
   7 bytes in segment NEAR_Z
 
 514 bytes of CODE memory (+ 11 bytes shared)
   7 bytes of DATA memory (+  4 bytes shared)

Errors: none
Warnings: none
