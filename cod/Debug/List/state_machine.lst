###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       15/Jan/2026  22:36:27
# Copyright 1996-2022 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\state_machine.c
#    Command line =  
#        -f C:\Users\vboxuser\AppData\Local\Temp\EWDD9D.tmp
#        (C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\state_machine.c
#        --cpu=m1280 -ms -o
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\Obj -lC
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -lA
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List\state_machine.lst
#    Object file  =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\Obj\state_machine.r90
#
###############################################################################

C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\state_machine.c
      1          #include "state_machine.h"
      2          #include "functii_adc.h"
      3          #include "functii_i2c.h"
      4          #include "functii_afisare.h"

    SEND_SUCCESSFUL,
    ^
"C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\functii_afisare.h",8  Error[Pe101]: 
          "SEND_SUCCESSFUL" has already been declared in the current scope (at
          line 17 of
          "C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\state_machine.h")

    SEND_NOT_SUCCESSFUL
    ^
"C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\functii_afisare.h",9  Error[Pe101]: 
          "SEND_NOT_SUCCESSFUL" has already been declared in the current scope
          (at line 18 of
          "C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\state_machine.h")

  } send_status_t;
    ^
"C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\functii_afisare.h",10  Error[Pe256]: 
          invalid redeclaration of type name "send_status_t" (declared at line
          19 of
          "C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\state_machine.h")
      5          #include "usart_my_lib.h"
      6          #include "functii_timer.h" // Pentru ms_ticks
      7          
      8          // Instantiere stari globale
      9          adc_state_t adc_state = ADC_REPAUS;
     10          driver_state_t driver_state = DRIVER_NEEDS_INIT;
     11          fir_state_t fir_state = FILTER_EMPTY;
     12          i2c_bus_state_t i2c_bus_state = I2C_OK;
     13          system_state_t system_state = SYSTEM_OK;
     14          timer_state_t timer_state = TIMER_COUNTER;
     15          usart_state_t usart_state = USART_IDLE;
     16          
     17          // Variabile de transfer între task-uri
     18          static uint16_t tensiune_raw = 0;
     19          static uint16_t tensiune_filtrata = 0;
     20          
     21          // --- TIMER TASK (Pentru 20ms) ---
     22          void timer_task() {
     23              static uint16_t start_time = 0;
     24              
     25              switch (timer_state) {
     26                  case TIMER_COUNTER:
     27                      start_time = ms_ticks; // Salvam momentul de start
     28                      timer_state = TIMER_WAIT;
     29                      break;
     30          
     31                  case TIMER_WAIT:
     32                      // Verificam daca au trecut 20ms
     33                      // Folosim diferenta pentru a evita problemele la overflow-ul uint16_t
     34                      if ((uint16_t)(ms_ticks - start_time) >= 20) {
     35                          timer_state = TIMER_EXPIRED;
     36                      }
     37                      break;
     38          
     39                  case TIMER_EXPIRED:
     40                      // Asteapta ca system_control sa proceseze ciclul si sa reseteze starea
     41                      break;
     42              }
     43          }
     44          
     45          // --- ADC TASK ---
     46          void adc_task() {
     47              switch (adc_state) {
     48                  case ADC_REPAUS:
     49                      ADCSRA |= (1 << ADSC); // Start conversie
     50                      adc_state = ADC_CONVERT;
     51                      break;
     52                  case ADC_CONVERT:
     53                      if (!(ADCSRA & (1 << ADSC))) adc_state = ADC_READY;
     54                      break;
     55                  case ADC_READY:
     56                      tensiune_raw = (uint32_t)ADC_Get_Result() * 5000UL / 1023UL; 
     57                      adc_state = ADC_REPAUS;
     58                      break;
     59              }
     60          }
     61          
     62          // --- FIR TASK ---
     63          void fir_task() {
     64              static uint32_t buffer_fir[8] = {0};
     65              static uint8_t idx = 0;
     66              
     67              buffer_fir[idx] = tensiune_raw;
     68              idx = (idx + 1) % 8;
     69              
     70              uint32_t suma = 0;
     71              for(uint8_t i=0; i<8; i++) suma += buffer_fir[i];
     72              tensiune_filtrata = suma / 8;
     73              
     74              fir_state = FILTER_READY;
     75          }
     76          
     77          // --- DRIVER TASK ---
     78          void driver_task(uint16_t tensiune) {
     79              static uint16_t safety_counter = 0;
     80              switch (driver_state) {
     81                  case DRIVER_NEEDS_INIT:
     82                      if (setup_7_segm() == SEND_SUCCESSFUL) {
     83                          driver_state = DRIVER_OK;
     84                          safety_counter = 0;
     85                      }
     86                      break;
     87                  case DRIVER_OK:
     88                      if (afisare_tensiune(tensiune) != SEND_SUCCESSFUL) {
     89                          driver_state = DRIVER_NEEDS_INIT;
     90                      }
     91                      if (++safety_counter >= 100) driver_state = DRIVER_NEEDS_INIT;
     92                      break;
     93              }
     94          }
     95          
     96          // --- USART TASK ---
     97          void usart_task() {
     98              switch (usart_state) {
     99                  case USART_IDLE:
    100                      if (fir_state == FILTER_READY) usart_state = USART_SENDING;
    101                      break;
    102                  case USART_SENDING:
    103                      my_print(INTEGER, &tensiune_filtrata);
    104                      usart_state = USART_COMPLETE;
    105                      break;
    106                  case USART_COMPLETE:
    107                      usart_state = USART_IDLE;
    108                      break;
    109              }
    110          }
    111          
    112          // --- SYSTEM CONTROL ---
    113          void system_control() {
    114              // 1. Gestionam timpul
    115              timer_task();
    116          
    117              // 2. Daca au trecut 20ms, executam lantul de procesare
    118              if (timer_state == TIMER_EXPIRED) {
    119                  
    120                  adc_task();
    121                  
    122                  // Continuam doar daca ADC-ul a terminat conversia
    123                  if (adc_state == ADC_READY) {
    124                      fir_task();
    125                      driver_task(tensiune_filtrata);
    126                      usart_task();
    127                      
    128                      // 3. Resetam starea timer-ului si a flag-urilor pentru urmatorul ciclu
    129                      timer_state = TIMER_COUNTER;
    130                      adc_state = ADC_REPAUS;
    131                      fir_state = FILTER_EMPTY;
    132                  }
    133              }
    134              
    135              // Logica de eroare sistem
    136              if (driver_state == DRIVER_NEEDS_INIT) system_state = SYSTEM_WARNING;
    137              else system_state = SYSTEM_OK;
    138          }

Errors: 3
Warnings: none
