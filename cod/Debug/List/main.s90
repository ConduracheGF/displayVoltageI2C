///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR      15/Jan/2026  22:50:42
// Copyright 1996-2022 IAR Systems AB.
//
//    Source file  =  C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\main.c
//    Command line =  
//        -f C:\Users\vboxuser\AppData\Local\Temp\EWB94B.tmp
//        (C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\main.c --cpu=m1280
//        -ms -o C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\Obj -lC
//        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -lA
//        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -y
//        --initializers_in_flash --no_cse --no_inline --no_code_motion
//        --no_cross_call --no_clustering --no_tbaa --debug
//        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
//        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
//    Locale       =  English_USA.1252
//    List file    =  
//        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List\main.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME main

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "ATmega1280"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "true"
        RTMODEL "__memory_model", "2"
        RTMODEL "__no_rampd", "enabled"
        RTMODEL "__rt_version", "3"
        RTMODEL "__vtable_memory", "__nearflash"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC main
        
          CFI Names cfiNames0
          CFI StackFrame CFA_Y Y DATA
          CFI StackFrame CFA_SP SP DATA
          CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
          CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
          CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
          CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
          CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
          CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
          CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
          CFI ResourceParts SP SPH, SPL
          CFI ResourceParts Y R29, R28
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign 1
          CFI ReturnAddress ?Ret CODE
          CFI CFA_Y Y+0
          CFI CFA_SP SP+2
          CFI ?RetPad 0
          CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
          CFI ?RetLow Frame(CFA_SP, 0)
          CFI ?Ret Concat
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 SameValue
          CFI R13 SameValue
          CFI R14 SameValue
          CFI R15 SameValue
          CFI R16 Undefined
          CFI R17 Undefined
          CFI R18 Undefined
          CFI R19 Undefined
          CFI R20 Undefined
          CFI R21 Undefined
          CFI R22 Undefined
          CFI R23 Undefined
          CFI R24 SameValue
          CFI R25 SameValue
          CFI R26 SameValue
          CFI R27 SameValue
          CFI R28 Undefined
          CFI R29 Undefined
          CFI R30 Undefined
          CFI R31 Undefined
          CFI ?RetHighByteMask SameValue
          CFI SPH Undefined
          CFI SPL Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN ADC_Get_Filtered_Value
        EXTERN ADC_Init
        EXTERN ADC_Is_Data_Ready
        EXTERN ADC_Task_Run
        EXTERN Display_Is_Error
        EXTERN Display_Task_Run
        EXTERN Timer0_Init
        EXTERN Timer_Check_20ms
        EXTERN USART_Is_Ready
        EXTERN USART_Task_Run
        EXTERN USART_initialize
        EXTERN i2c_init
        EXTERN my_print

// C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\main.c
//    1 #include <intrinsics.h>
//    2 #include <ioavr.h>
//    3 #include <stdint.h>
//    4 #include <stdbool.h>
//    5 
//    6 #include "functii_i2c.h"
//    7 #include "usart_control.h"
//    8 #include "usart_my_lib.h"
//    9 #include "functii_adc.h"
//   10 #include "functii_afisare.h"
//   11 #include "functii_timer.h"
//   12 
//   13 typedef enum {
//   14   SYSTEM_OK,
//   15   SYSTEM_ERROR
//   16 } system_status_t;
//   17 

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   18 static system_status_t system_status = SYSTEM_OK;
system_status:
        DS8 1
//   19 

        RSEG `CODE`:CODE:NOROOT(1)
//   20 int main(void) {
main:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function main
        CODE
        SBIW    R29:R28, 2
          CFI CFA_Y Y+2
//   21     
//   22     // Initializare ADC (configurare registre, fara start conversie)
//   23     ADC_Init();
          CFI FunCall ADC_Init
        CALL    ADC_Init
//   24     
//   25     // Initializare I2C pentru comunicarea cu driverul de display
//   26     i2c_init();
          CFI FunCall i2c_init
        CALL    i2c_init
//   27     
//   28     // Initializare USART cu Baud Rate calculat (9600 bps)
//   29     USART_initialize(BAUD_RATE);
        LDI     R16, 103
        LDI     R17, 0
          CFI FunCall USART_initialize
        CALL    USART_initialize
//   30     
//   31     // Initializare Timer0 pentru baza de timp de 1ms
//   32     Timer0_Init();
          CFI FunCall Timer0_Init
        CALL    Timer0_Init
//   33     
//   34     // Activare globala a intreruperilor (necesar pentru I2C, USART si Timer)
//   35     __enable_interrupt();
        SEI
//   36 
//   37     // Variabila locala pentru a stoca valoarea de afisat/trimis
//   38     uint16_t valoare_curenta = 0;
        LDI     R16, 0
        ST      Y, R16
        LDI     R16, 0
        STD     Y+1, R16
//   39 
//   40     while (1) {
//   41         
//   42         // Verificam daca au trecut 20ms (bataia inimii a sistemului)
//   43         if (Timer_Check_20ms()) {
??main_0:
          CFI FunCall Timer_Check_20ms
        CALL    Timer_Check_20ms
        TST     R16
        BREQ    ??main_1
//   44             
//   45             // Management ADC: 
//   46             // Task-ul gestioneaza singur Starile: Pornire -> Asteptare -> Citire -> Filtrare FIR
//   47             ADC_Task_Run();
          CFI FunCall ADC_Task_Run
        CALL    ADC_Task_Run
//   48             
//   49             // Verificam daca avem date noi de la ADC
//   50             if (ADC_Is_Data_Ready()) {
          CFI FunCall ADC_Is_Data_Ready
        CALL    ADC_Is_Data_Ready
        TST     R16
        BREQ    ??main_2
//   51                 
//   52                 // Preluam valoarea filtrata (media ultimelor 8 masuratori)
//   53                 valoare_curenta = ADC_Get_Filtered_Value();
          CFI FunCall ADC_Get_Filtered_Value
        CALL    ADC_Get_Filtered_Value
        ST      Y, R16
        STD     Y+1, R17
//   54                 
//   55                 // Management Display:
//   56                 // Trimite datele catre AS1115 via I2C. 
//   57                 // Daca I2C-ul este ocupat sau da eroare, task-ul va incerca sa re-initializeze driverul.
//   58                 Display_Task_Run(valoare_curenta);
        LD      R16, Y
        LDD     R17, Y+1
          CFI FunCall Display_Task_Run
        CALL    Display_Task_Run
//   59                 
//   60                 // Management USART (State Machine):
//   61                 // Trimitem pe seriala doar daca masina de stari USART este in IDLE 
//   62                 // (adica bufferul circular de transmisie a fost golit anterior)
//   63                 if (USART_Is_Ready()) {
          CFI FunCall USART_Is_Ready
        CALL    USART_Is_Ready
        TST     R16
        BREQ    ??main_2
//   64                     my_print(INTEGER, &valoare_curenta);
        MOVW    R19:R18, R29:R28
        LDI     R16, 0
          CFI FunCall my_print
        CALL    my_print
//   65                 }
//   66             }
//   67             
//   68             // Verificare Siguranta:
//   69             // Daca driverul de afisare raporteaza erori critice repetate
//   70             if (Display_Is_Error()) {
??main_2:
          CFI FunCall Display_Is_Error
        CALL    Display_Is_Error
        TST     R16
        BREQ    ??main_3
//   71                 system_status = SYSTEM_ERROR;
        LDI     R16, 1
        STS     system_status, R16
        RJMP    ??main_1
//   72             } else {
//   73                 system_status = SYSTEM_OK;
??main_3:
        LDI     R16, 0
        STS     system_status, R16
//   74             }
//   75         }
//   76         
//   77         // Task-uri de fundal:
//   78         // Acestea ruleaza cat mai des posibil (in afara if-ului de 20ms) 
//   79         // pentru a procesa cozile de date sau flag-urile de hardware.
//   80         USART_Task_Run(); 
??main_1:
          CFI FunCall USART_Task_Run
        CALL    USART_Task_Run
        RJMP    ??main_0
//   81     }
//   82 }
          CFI EndBlock cfiBlock0

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,022H
__?EEARH:

        RSEG INITTAB:CODE:NOROOT(0)
        DATA
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DP      0
        REQUIRE ?need_segment_init

        END
// 
// 112 bytes in segment CODE
//   7 bytes in segment INITTAB
//   1 byte  in segment NEAR_Z
// 
// 112 bytes of CODE memory (+ 7 bytes shared)
//   1 byte  of DATA memory
//
//Errors: none
//Warnings: 1
