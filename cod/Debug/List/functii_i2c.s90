///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR      18/Jan/2026  12:23:17
// Copyright 1996-2022 IAR Systems AB.
//
//    Source file  =  
//        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\functii_i2c.c
//    Command line =  
//        -f C:\Users\student\AppData\Local\Temp\EWF746.tmp
//        (C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\functii_i2c.c
//        --cpu=m1280 -ms -o
//        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\Obj
//        -lC
//        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\List
//        -lA
//        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\List
//        -y --initializers_in_flash --no_cse --no_inline --no_code_motion
//        --no_cross_call --no_clustering --no_tbaa --debug
//        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
//        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
//    Locale       =  English_USA.1252
//    List file    =  
//        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\List\functii_i2c.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME functii_i2c

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "ATmega1280"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "true"
        RTMODEL "__memory_model", "2"
        RTMODEL "__no_rampd", "enabled"
        RTMODEL "__rt_version", "3"
        RTMODEL "__vtable_memory", "__nearflash"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBWEAK `??TWI_ISR::??INTVEC 156`
        PUBLIC TWI_ISR
        PUBWEAK _A_TWBR
        PUBWEAK _A_TWCR
        PUBWEAK _A_TWDR
        PUBWEAK _A_TWSR
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC g_i2c_state
        PUBLIC i2c_get_last_status
        PUBLIC i2c_init
        PUBLIC i2c_is_busy
        PUBLIC i2c_read_transaction
        PUBLIC i2c_write_transaction
        
          CFI Names cfiNames0
          CFI StackFrame CFA_Y Y DATA
          CFI StackFrame CFA_SP SP DATA
          CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
          CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
          CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
          CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
          CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
          CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
          CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
          CFI ResourceParts SP SPH, SPL
          CFI ResourceParts Y R29, R28
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign 1
          CFI ReturnAddress ?Ret CODE
          CFI CFA_Y Y+0
          CFI CFA_SP SP+2
          CFI ?RetPad 0
          CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
          CFI ?RetLow Frame(CFA_SP, 0)
          CFI ?Ret Concat
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 SameValue
          CFI R13 SameValue
          CFI R14 SameValue
          CFI R15 SameValue
          CFI R16 Undefined
          CFI R17 Undefined
          CFI R18 Undefined
          CFI R19 Undefined
          CFI R20 Undefined
          CFI R21 Undefined
          CFI R22 Undefined
          CFI R23 Undefined
          CFI R24 SameValue
          CFI R25 SameValue
          CFI R26 SameValue
          CFI R27 SameValue
          CFI R28 Undefined
          CFI R29 Undefined
          CFI R30 Undefined
          CFI R31 Undefined
          CFI ?RetHighByteMask SameValue
          CFI SPH Undefined
          CFI SPL Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign 1
          CFI ReturnAddress ?Ret CODE
          CFI CFA_Y Y+0
          CFI CFA_SP SP+2
          CFI ?RetPad 0
          CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
          CFI ?RetLow Frame(CFA_SP, 0)
          CFI ?Ret Concat
          CFI R0 SameValue
          CFI R1 SameValue
          CFI R2 SameValue
          CFI R3 SameValue
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 SameValue
          CFI R13 SameValue
          CFI R14 SameValue
          CFI R15 SameValue
          CFI R16 SameValue
          CFI R17 SameValue
          CFI R18 SameValue
          CFI R19 SameValue
          CFI R20 SameValue
          CFI R21 SameValue
          CFI R22 SameValue
          CFI R23 SameValue
          CFI R24 SameValue
          CFI R25 SameValue
          CFI R26 SameValue
          CFI R27 SameValue
          CFI R28 Undefined
          CFI R29 Undefined
          CFI R30 SameValue
          CFI R31 SameValue
          CFI ?RetHighByteMask SameValue
          CFI SPH Undefined
          CFI SPL Undefined
          CFI EndCommon cfiCommon1
        
TWI_ISR             SYMBOL "TWI_ISR"
`??TWI_ISR::??INTVEC 156` SYMBOL "??INTVEC 156", TWI_ISR

// C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\functii_i2c.c
//    1 #include "functii_i2c.h"
//    2 #include <ioavr.h>

        ASEGN ABSOLUTE:DATA:NOROOT,0bcH
// union <unnamed> volatile __io _A_TWCR
_A_TWCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0bbH
// union <unnamed> volatile __io _A_TWDR
_A_TWDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0b9H
// union <unnamed> volatile __io _A_TWSR
_A_TWSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0b8H
// union <unnamed> volatile __io _A_TWBR
_A_TWBR:
        DS8 1
//    3 #include <inavr.h>
//    4 #include <stdint.h>
//    5 
//    6 // Conditie START transmisa
//    7 #define TW_START 0x08
//    8 // Master Transmit: adresa + W transmisa, ACK primit
//    9 #define TW_MT_SLA_ACK 0x18
//   10 // Master Transmit: octet de date transmis, ACK primit
//   11 #define TW_MT_DATA_ACK 0x28
//   12 // Master Receive: adresa + R transmisa, ACK primit
//   13 #define TW_MR_SLA_ACK 0x40
//   14 // Master Receive: octet de date recep?ionat, ACK returnat
//   15 #define TW_MR_DATA_ACK 0x50
//   16 // Master Receive: octet de date recep?ionat, NACK returnat
//   17 #define TW_MR_DATA_NACK 0x58 
//   18 
//   19 
//   20 // Starea curenta

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   21 volatile i2c_state_t g_i2c_state = I2C_STATE_IDLE;
g_i2c_state:
        DS8 1
//   22 // Ultimul status returnat

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   23 static volatile i2c_status_t g_i2c_status = I2C_STATUS_SUCCESS;
g_i2c_status:
        DS8 1

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   24 static uint8_t g_slave_address; // Adresa slave (cu bitul R/W inclus)
g_slave_address:
        DS8 1

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   25 static uint8_t* g_data_ptr; // Pointer catre bufferul de date
g_data_ptr:
        DS8 2

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   26 static uint8_t g_data_len; // Lungimea totala a transferului
g_data_len:
        DS8 1

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   27 static uint8_t g_data_idx; // Indexul curent în buffer
g_data_idx:
        DS8 1
//   28 
//   29 /*
//   30 * Functia initializeaza modulul TWI/I2C.
//   31 * - Configureaza prescaler-ul si frecven?a de lucru (SCL_CLOCK).
//   32 * - Activeaza perifericul TWI (fara a activa întreruperile înca).
//   33 */

        RSEG `CODE`:CODE:NOROOT(1)
//   34 void i2c_init(void) {
i2c_init:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function i2c_init
          CFI NoCalls
        CODE
//   35   TWSR = 0x00; // Prescaler = 1
        LDI     R16, 0
        STS     _A_TWSR, R16
//   36   // Baud-rate generator pentru SCL
//   37   TWBR = ((F_CPU / SCL_CLOCK) - 16) / 2;
        LDI     R16, 72
        STS     _A_TWBR, R16
//   38   // Activeaza TWI, fara întreruperi
//   39   TWCR = (1 << TWEN);
        LDI     R16, 4
        STS     _A_TWCR, R16
//   40 }
        RET
          CFI EndBlock cfiBlock0
        REQUIRE _A_TWSR
        REQUIRE _A_TWBR
        REQUIRE _A_TWCR
//   41 
//   42 /*
//   43 * Func?ia verifica daca magistrala I2C este ocupata.
//   44 * Returneaza:
//   45 * - 1 daca o tranzac?ie este în desfa?urare
//   46 * - 0 daca modulul este inactiv (IDLE)
//   47 */

        RSEG `CODE`:CODE:NOROOT(1)
//   48 uint8_t i2c_is_busy(void) {
i2c_is_busy:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function i2c_is_busy
          CFI NoCalls
        CODE
//   49   return (g_i2c_state != I2C_STATE_IDLE);
        LDS     R16, g_i2c_state
        TST     R16
        BREQ    ??i2c_is_busy_0
        LDI     R16, 1
        RET
??i2c_is_busy_0:
        LDI     R16, 0
        RET
//   50 }
          CFI EndBlock cfiBlock1
//   51 
//   52 
//   53 /*
//   54 * Functia returneaza ultimul status înregistrat al tranzac?iei.
//   55 * Poate fi folosita pentru depanare.
//   56 */

        RSEG `CODE`:CODE:NOROOT(1)
//   57 i2c_status_t i2c_get_last_status(void) {
i2c_get_last_status:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function i2c_get_last_status
          CFI NoCalls
        CODE
//   58   return g_i2c_status;
        LDS     R16, g_i2c_status
        RET
//   59 }
          CFI EndBlock cfiBlock2
//   60 
//   61 
//   62 /*
//   63 * Func?ia porne?te o tranzactie de scriere NON-BLOCANTA.
//   64 * Returneaza:
//   65 * - I2C_STATUS_SUCCESS daca tranzactia a fost pornita
//   66 * - I2C_STATUS_BUSY daca magistrala era deja ocupata
//   67 */

        RSEG `CODE`:CODE:NOROOT(1)
//   68 i2c_status_t i2c_write_transaction(uint8_t address, uint8_t* data, uint8_t length) {
i2c_write_transaction:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function i2c_write_transaction
          CFI NoCalls
        CODE
        MOV     R20, R16
//   69   if (g_i2c_state != I2C_STATE_IDLE) {
        LDS     R16, g_i2c_state
        TST     R16
        BREQ    ??i2c_write_transaction_0
//   70     return I2C_STATUS_BUSY;
        LDI     R16, 1
        RET
//   71   }
//   72   g_i2c_state = I2C_STATE_WRITING;
??i2c_write_transaction_0:
        LDI     R16, 1
        STS     g_i2c_state, R16
//   73   g_i2c_status = I2C_STATUS_BUSY;
        LDI     R16, 1
        STS     g_i2c_status, R16
//   74   g_slave_address = (address << 1) | TW_WRITE; // Adresa + bit W
        MOV     R16, R20
        LSL     R16
        STS     g_slave_address, R16
//   75   g_data_ptr = data;
        LDI     R30, LOW(g_data_ptr)
        LDI     R31, (g_data_ptr) >> 8
        ST      Z, R18
        STD     Z+1, R19
//   76   g_data_len = length;
        STS     g_data_len, R17
//   77   g_data_idx = 0;
        LDI     R16, 0
        STS     g_data_idx, R16
//   78   // Lansam tranzactia prin generarea condi?iei START + întrerupere
//   79   TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWIE);
        LDI     R16, 165
        STS     _A_TWCR, R16
//   80   
//   81   return I2C_STATUS_SUCCESS;
        LDI     R16, 0
        RET
          CFI EndBlock cfiBlock3
        REQUIRE _A_TWCR
//   82 }
//   83 
//   84 /*
//   85 * Func?ia porne?te o tranzac?ie de citire NON-BLOCANTA.
//   86 * Returneaza:
//   87 * - I2C_STATUS_SUCCESS daca tranzac?ia a fost pornita
//   88 * - I2C_STATUS_BUSY daca magistrala era deja ocupata
//   89 */

        RSEG `CODE`:CODE:NOROOT(1)
//   90 i2c_status_t i2c_read_transaction(uint8_t address, uint8_t* data, uint8_t length) {
i2c_read_transaction:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function i2c_read_transaction
          CFI NoCalls
        CODE
        MOV     R20, R16
//   91   if (g_i2c_state != I2C_STATE_IDLE) {
        LDS     R16, g_i2c_state
        TST     R16
        BREQ    ??i2c_read_transaction_0
//   92     return I2C_STATUS_BUSY; // Magistrala e ocupata
        LDI     R16, 1
        RET
//   93   }
//   94   g_i2c_state = I2C_STATE_READING;
??i2c_read_transaction_0:
        LDI     R16, 2
        STS     g_i2c_state, R16
//   95   g_i2c_status = I2C_STATUS_BUSY;
        LDI     R16, 1
        STS     g_i2c_status, R16
//   96   g_slave_address = (address << 1) | 1; // Adresa + bit R
        MOV     R16, R20
        LSL     R16
        ORI     R16, 0x01
        STS     g_slave_address, R16
//   97   g_data_ptr = data;
        LDI     R30, LOW(g_data_ptr)
        LDI     R31, (g_data_ptr) >> 8
        ST      Z, R18
        STD     Z+1, R19
//   98   g_data_len = length;
        STS     g_data_len, R17
//   99   g_data_idx = 0;
        LDI     R16, 0
        STS     g_data_idx, R16
//  100   // Pentru citire, ini?iem cu un START
//  101   TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN) | (1 << TWIE);
        LDI     R16, 165
        STS     _A_TWCR, R16
//  102   return I2C_STATUS_SUCCESS;
        LDI     R16, 0
        RET
          CFI EndBlock cfiBlock4
        REQUIRE _A_TWCR
//  103 }
//  104 
//  105 /*
//  106 * Aceasta rutina implementeaza logica ma?inii de stari pentru TWI/I2C.
//  107 * Gestioneaza atât opera?iile de scriere, cât ?i pe cele de citire,
//  108 * pe baza valorii registrului TWSR (status).
//  109 */
//  110 #pragma vector = TWI_vect

        RSEG `CODE`:CODE:NOROOT(1)
        CALL_GRAPH_ROOT TWI_ISR, "interrupt"
//  111 __interrupt void TWI_ISR(void) {
TWI_ISR:
          CFI Block cfiBlock5 Using cfiCommon1
          CFI Function TWI_ISR
          CFI NoCalls
        CODE
        ST      -Y, R31
          CFI R31 Frame(CFA_Y, -1)
          CFI CFA_Y Y+1
        ST      -Y, R30
          CFI R30 Frame(CFA_Y, -2)
          CFI CFA_Y Y+2
        ST      -Y, R20
          CFI R20 Frame(CFA_Y, -3)
          CFI CFA_Y Y+3
        ST      -Y, R19
          CFI R19 Frame(CFA_Y, -4)
          CFI CFA_Y Y+4
        ST      -Y, R18
          CFI R18 Frame(CFA_Y, -5)
          CFI CFA_Y Y+5
        ST      -Y, R17
          CFI R17 Frame(CFA_Y, -6)
          CFI CFA_Y Y+6
        ST      -Y, R16
          CFI R16 Frame(CFA_Y, -7)
          CFI CFA_Y Y+7
        IN      R19, 0x3F
        IN      R20, 0x3B
//  112   switch (TWSR & 0xF8) { // Se mascheaza doar bi?ii de status
        LDS     R16, _A_TWSR
        LDI     R17, 0
        ANDI    R16, 0xF8
        ANDI    R17, 0x00
        SUBI    R16, 8
        BREQ    ??TWI_ISR_0
        SUBI    R16, 16
        BREQ    ??TWI_ISR_1
        SUBI    R16, 16
        BREQ    ??TWI_ISR_1
        SUBI    R16, 24
        BREQ    ??TWI_ISR_2
        SUBI    R16, 16
        BRNE    $+2+2
        RJMP    ??TWI_ISR_3
        SUBI    R16, 8
        BRNE    $+2+2
        RJMP    ??TWI_ISR_4
        RJMP    ??TWI_ISR_5
//  113   case TW_START: // Condi?ie START trimisa
//  114     TWDR = g_slave_address; // Se trimite adresa + bit R/W
??TWI_ISR_0:
        LDS     R16, g_slave_address
        STS     _A_TWDR, R16
//  115     TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
        LDI     R16, 133
        STS     _A_TWCR, R16
//  116     break;
        RJMP    ??TWI_ISR_6
//  117     // Slave a raspuns cu ACK dupa adresa
//  118   case TW_MT_SLA_ACK:
//  119     // Slave a raspuns cu ACK dupa un octet de date
//  120   case TW_MT_DATA_ACK:
//  121     if (g_data_idx < g_data_len) {
??TWI_ISR_1:
        LDS     R16, g_data_idx
        LDS     R17, g_data_len
        CP      R16, R17
        BRCC    ??TWI_ISR_7
//  122       // Mai sunt date de transmis
//  123       TWDR = g_data_ptr[g_data_idx++];
        LDS     R16, g_data_idx
        LDI     R17, 0
        LDS     R30, g_data_ptr
        LDS     R31, (g_data_ptr + 1)
        ADD     R30, R16
        ADC     R31, R17
        LD      R16, Z
        STS     _A_TWDR, R16
        LDS     R16, g_data_idx
        INC     R16
        STS     g_data_idx, R16
//  124       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
        LDI     R16, 133
        STS     _A_TWCR, R16
        RJMP    ??TWI_ISR_6
//  125     } else {
//  126       // S-a terminat transmisia
//  127       TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
??TWI_ISR_7:
        LDI     R16, 148
        STS     _A_TWCR, R16
//  128       g_i2c_status = I2C_STATUS_SUCCESS;
        LDI     R16, 0
        STS     g_i2c_status, R16
//  129       g_i2c_state = I2C_STATE_IDLE;
        LDI     R16, 0
        STS     g_i2c_state, R16
//  130     }
//  131     break;
        RJMP    ??TWI_ISR_6
//  132     // S-a trimis adresa + R, Slave a raspuns cu ACK
//  133   case TW_MR_SLA_ACK:
//  134     // Daca mai este mai mult de 1 octet de citit e returnat ACK
//  135     if (g_data_len - g_data_idx > 1) {
??TWI_ISR_2:
        LDS     R30, g_data_len
        LDI     R31, 0
        LDS     R16, g_data_idx
        LDI     R17, 0
        SUB     R30, R16
        SBC     R31, R17
        SBIW    R31:R30, 2
        BRLT    ??TWI_ISR_8
//  136       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE) | (1 << TWEA);
        LDI     R16, 197
        STS     _A_TWCR, R16
        RJMP    ??TWI_ISR_6
//  137     } else {
//  138       // Ultimul octet, deci se returneaza NACK
//  139       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
??TWI_ISR_8:
        LDI     R16, 133
        STS     _A_TWCR, R16
//  140     }
//  141     break;
        RJMP    ??TWI_ISR_6
//  142   case TW_MR_DATA_ACK: // S-a citit un octet ?i s-a trimis ACK
//  143     g_data_ptr[g_data_idx++] = TWDR;
??TWI_ISR_3:
        LDS     R18, _A_TWDR
        LDS     R16, g_data_idx
        LDI     R17, 0
        LDS     R30, g_data_ptr
        LDS     R31, (g_data_ptr + 1)
        ADD     R30, R16
        ADC     R31, R17
        ST      Z, R18
        LDS     R16, g_data_idx
        INC     R16
        STS     g_data_idx, R16
//  144     if (g_data_len - g_data_idx > 1) {
        LDS     R30, g_data_len
        LDI     R31, 0
        LDS     R16, g_data_idx
        LDI     R17, 0
        SUB     R30, R16
        SBC     R31, R17
        SBIW    R31:R30, 2
        BRLT    ??TWI_ISR_9
//  145       // Mai sunt date de citit, deci se cere cu ACK
//  146       TWCR = (1 << TWINT)|(1 << TWEN)|(1 << TWIE) | (1 << TWEA);
        LDI     R16, 197
        STS     _A_TWCR, R16
        RJMP    ??TWI_ISR_6
//  147     } else {
//  148       // Urmeaza ultimul octet, deci se cere fara ACK
//  149       TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWIE);
??TWI_ISR_9:
        LDI     R16, 133
        STS     _A_TWCR, R16
//  150     }
//  151     break;
        RJMP    ??TWI_ISR_6
//  152     // S-a citit ultimul octet ?i s-a trimis NACK
//  153   case TW_MR_DATA_NACK:
//  154     g_data_ptr[g_data_idx++] = TWDR;
??TWI_ISR_4:
        LDS     R18, _A_TWDR
        LDS     R16, g_data_idx
        LDI     R17, 0
        LDS     R30, g_data_ptr
        LDS     R31, (g_data_ptr + 1)
        ADD     R30, R16
        ADC     R31, R17
        ST      Z, R18
        LDS     R16, g_data_idx
        INC     R16
        STS     g_data_idx, R16
//  155     TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN); // STOP
        LDI     R16, 148
        STS     _A_TWCR, R16
//  156     g_i2c_status = I2C_STATUS_SUCCESS;
        LDI     R16, 0
        STS     g_i2c_status, R16
//  157     g_i2c_state = I2C_STATE_IDLE;
        LDI     R16, 0
        STS     g_i2c_state, R16
//  158     break;
        RJMP    ??TWI_ISR_6
//  159   default:
//  160     g_i2c_status = I2C_STATUS_ERROR; // Se semnaleaza eroarea
??TWI_ISR_5:
        LDI     R16, 2
        STS     g_i2c_status, R16
//  161     // STOP – se elibereaza magistrala
//  162     TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
        LDI     R16, 148
        STS     _A_TWCR, R16
//  163     g_i2c_state = I2C_STATE_IDLE;
        LDI     R16, 0
        STS     g_i2c_state, R16
//  164     break;
//  165   }
//  166 }
??TWI_ISR_6:
        OUT     0x3B, R20
        OUT     0x3F, R19
        LD      R16, Y+
          CFI R16 SameValue
          CFI CFA_Y Y+6
        LD      R17, Y+
          CFI R17 SameValue
          CFI CFA_Y Y+5
        LD      R18, Y+
          CFI R18 SameValue
          CFI CFA_Y Y+4
        LD      R19, Y+
          CFI R19 SameValue
          CFI CFA_Y Y+3
        LD      R20, Y+
          CFI R20 SameValue
          CFI CFA_Y Y+2
        LD      R30, Y+
          CFI R30 SameValue
          CFI CFA_Y Y+1
        LD      R31, Y+
          CFI R31 SameValue
          CFI CFA_Y Y+0
        RETI
          CFI EndBlock cfiBlock5
        REQUIRE _A_TWDR
        REQUIRE _A_TWCR
        REQUIRE _A_TWSR

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,022H
__?EEARH:

        COMMON INTVEC:CODE:ROOT(1)
        ORG 156
`??TWI_ISR::??INTVEC 156`:
        CODE
        JMP     TWI_ISR

        RSEG INITTAB:CODE:NOROOT(0)
        DATA
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DP      0
        REQUIRE ?need_segment_init

        END
// 
//   4 bytes in segment ABSOLUTE
// 514 bytes in segment CODE
//   7 bytes in segment INITTAB
//   4 bytes in segment INTVEC
//   7 bytes in segment NEAR_Z
// 
// 514 bytes of CODE memory (+ 11 bytes shared)
//   7 bytes of DATA memory (+  4 bytes shared)
//
//Errors: none
//Warnings: none
