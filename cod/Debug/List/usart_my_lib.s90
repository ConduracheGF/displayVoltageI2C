///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR      15/Jan/2026  22:50:46
// Copyright 1996-2022 IAR Systems AB.
//
//    Source file  =  
//        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\usart_my_lib.c
//    Command line =  
//        -f C:\Users\vboxuser\AppData\Local\Temp\EWC45A.tmp
//        (C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\usart_my_lib.c
//        --cpu=m1280 -ms -o
//        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\Obj -lC
//        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -lA
//        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -y
//        --initializers_in_flash --no_cse --no_inline --no_code_motion
//        --no_cross_call --no_clustering --no_tbaa --debug
//        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
//        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
//    Locale       =  English_USA.1252
//    List file    =  
//        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List\usart_my_lib.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME usart_my_lib

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "ATmega1280"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "true"
        RTMODEL "__memory_model", "2"
        RTMODEL "__no_rampd", "enabled"
        RTMODEL "__rt_version", "3"
        RTMODEL "__vtable_memory", "__nearflash"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?EPILOGUE_B16_L09
        EXTERN ?EPILOGUE_B3_L09
        EXTERN ?EPILOGUE_B5_L09
        EXTERN ?EPILOGUE_B8_L09
        EXTERN ?F2SL_L04
        EXTERN ?F_ADD_L04
        EXTERN ?F_CMP_LT_L04
        EXTERN ?F_MUL_L04
        EXTERN ?F_SUB_L04
        EXTERN ?PROLOGUE16_L09
        EXTERN ?PROLOGUE3_L09
        EXTERN ?PROLOGUE5_L09
        EXTERN ?PROLOGUE8_L09
        EXTERN ?Register_R10_is_cg_reg
        EXTERN ?Register_R11_is_cg_reg
        EXTERN ?Register_R12_is_cg_reg
        EXTERN ?Register_R13_is_cg_reg
        EXTERN ?Register_R14_is_cg_reg
        EXTERN ?Register_R15_is_cg_reg
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?Register_R6_is_cg_reg
        EXTERN ?Register_R7_is_cg_reg
        EXTERN ?Register_R8_is_cg_reg
        EXTERN ?Register_R9_is_cg_reg
        EXTERN ?SL2F_L04
        EXTERN ?SS_DIVMOD_L02
        EXTERN ?SS_SHR_L02
        EXTERN ?S_EC_MUL_L02
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC characterTransmit
        PUBLIC doubleTransmit
        PUBLIC hexadecimalTransmit
        PUBLIC integerTransmit
        PUBLIC my_print
        
          CFI Names cfiNames0
          CFI StackFrame CFA_Y Y DATA
          CFI StackFrame CFA_SP SP DATA
          CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
          CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
          CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
          CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
          CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
          CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
          CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
          CFI ResourceParts SP SPH, SPL
          CFI ResourceParts Y R29, R28
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign 1
          CFI ReturnAddress ?Ret CODE
          CFI CFA_Y Y+0
          CFI CFA_SP SP+2
          CFI ?RetPad 0
          CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
          CFI ?RetLow Frame(CFA_SP, 0)
          CFI ?Ret Concat
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 SameValue
          CFI R13 SameValue
          CFI R14 SameValue
          CFI R15 SameValue
          CFI R16 Undefined
          CFI R17 Undefined
          CFI R18 Undefined
          CFI R19 Undefined
          CFI R20 Undefined
          CFI R21 Undefined
          CFI R22 Undefined
          CFI R23 Undefined
          CFI R24 SameValue
          CFI R25 SameValue
          CFI R26 SameValue
          CFI R27 SameValue
          CFI R28 Undefined
          CFI R29 Undefined
          CFI R30 Undefined
          CFI R31 Undefined
          CFI ?RetHighByteMask SameValue
          CFI SPH Undefined
          CFI SPL Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN USART_transmit_string

// C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\usart_my_lib.c
//    1 #include "usart_my_lib.h"
//    2 
//    3 // Buffer auxiliar pentru construirea șirului de caractere

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//    4 static uint8_t aux1[10] = { 0 }, aux2[10] = { 0 };
aux1:
        DS8 10

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
aux2:
        DS8 10
//    5 
//    6 // Funcția de transmitere a unui număr întreg pe serială

        RSEG `CODE`:CODE:NOROOT(1)
//    7 void integerTransmit(void *p) {
integerTransmit:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function integerTransmit
        CODE
        CALL    ?PROLOGUE8_L09
          CFI R7 Frame(CFA_Y, -1)
          CFI R6 Frame(CFA_Y, -2)
          CFI R5 Frame(CFA_Y, -3)
          CFI R4 Frame(CFA_Y, -4)
          CFI R27 Frame(CFA_Y, -5)
          CFI R26 Frame(CFA_Y, -6)
          CFI R25 Frame(CFA_Y, -7)
          CFI R24 Frame(CFA_Y, -8)
          CFI CFA_Y Y+8
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        MOVW    R7:R6, R17:R16
//    8   // Se inițializează indicii pentru construcția șirului de caractere
//    9   int16_t index = 0, i = 0;
        LDI     R26, 0
        LDI     R27, 0
        CLR     R4
        CLR     R5
//   10   // Se preia valoarea întreagă din pointer
//   11   int16_t x = (*(int16_t *)(p));
        MOVW    R31:R30, R7:R6
        LD      R24, Z
        LDD     R25, Z+1
//   12   // Se tratează cazul numerelor negative
//   13   if (x < 0) {
        TST     R25
        BRPL    ??integerTransmit_0
//   14     aux1[index] = '-';  // Se adaugă semnul minus
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 45
        ST      Z, R16
//   15     index++;
        ADIW    R27:R26, 1
//   16     x *= (-1);
        MOVW    R17:R16, R25:R24
        LDI     R20, 255
        LDI     R21, 255
          CFI FunCall ?S_EC_MUL_L02
        CALL    ?S_EC_MUL_L02
        MOVW    R25:R24, R17:R16
//   17     // Se convertește la valoare pozitivă
//   18   }
//   19   // Se extrag cifrele numărului în ordine inversă
//   20   do {
//   21     // Se convertește cifra la caracter ASCII
//   22     uint8_t c = x % 10 + '0';
??integerTransmit_0:
        LDI     R20, 10
        LDI     R21, 0
        MOVW    R17:R16, R25:R24
          CFI FunCall ?SS_DIVMOD_L02
        CALL    ?SS_DIVMOD_L02
        MOV     R18, R20
        SUBI    R18, 208
//   23 
//   24     // Se stochează temporar în buffer auxiliar
//   25     aux2[i] = c;
        MOVW    R31:R30, R5:R4
        SUBI    R30, LOW((-(aux2) & 0xFFFF))
        SBCI    R31, (-(aux2) & 0xFFFF) >> 8
        ST      Z, R18
//   26     i++;
        LDI     R16, 1
        ADD     R4, R16
        LDI     R16, 0
        ADC     R5, R16
//   27     // Se reduce numărul
//   28     x = x / 10;
        LDI     R20, 10
        LDI     R21, 0
        MOVW    R17:R16, R25:R24
          CFI FunCall ?SS_DIVMOD_L02
        CALL    ?SS_DIVMOD_L02
        MOVW    R25:R24, R17:R16
//   29   } while (x != 0);
        MOV     R16, R24
        OR      R16, R25
        BRNE    ??integerTransmit_0
//   30   // Se copiază cifrele în ordinea corectă în bufferul final
//   31   for (int16_t j = i - 1; j >= 0; j--) {
        MOVW    R17:R16, R5:R4
        SUBI    R16, 1
        SBCI    R17, 0
??integerTransmit_1:
        TST     R17
        BRMI    ??integerTransmit_2
//   32     aux1[index] = aux2[j];
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(aux2) & 0xFFFF))
        SBCI    R31, (-(aux2) & 0xFFFF) >> 8
        LD      R18, Z
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        ST      Z, R18
//   33     index++;
        ADIW    R27:R26, 1
//   34   }
        SUBI    R16, 1
        SBCI    R17, 0
        RJMP    ??integerTransmit_1
//   35   // Se adaugă caracterele de sfârșit de linie
//   36   aux1[index] = '\n';
??integerTransmit_2:
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 10
        ST      Z, R16
//   37   index++;
        ADIW    R27:R26, 1
//   38   aux1[index] = '\r';
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 13
        ST      Z, R16
//   39   index++;
        ADIW    R27:R26, 1
//   40   // Se transmite șirul format către modulul USART
//   41   USART_transmit_string(aux1, index);
        MOVW    R19:R18, R27:R26
        LDI     R16, LOW(aux1)
        LDI     R17, (aux1) >> 8
          CFI FunCall USART_transmit_string
        CALL    USART_transmit_string
//   42 }
        LDI     R30, 8
        JMP     ?EPILOGUE_B8_L09
          CFI EndBlock cfiBlock0
//   43 
//   44 // Funcția de transmitere a unui număr hexazecimal pe serială

        RSEG `CODE`:CODE:NOROOT(1)
//   45 void hexadecimalTransmit(void *p) {
hexadecimalTransmit:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function hexadecimalTransmit
        CODE
        CALL    ?PROLOGUE8_L09
          CFI R7 Frame(CFA_Y, -1)
          CFI R6 Frame(CFA_Y, -2)
          CFI R5 Frame(CFA_Y, -3)
          CFI R4 Frame(CFA_Y, -4)
          CFI R27 Frame(CFA_Y, -5)
          CFI R26 Frame(CFA_Y, -6)
          CFI R25 Frame(CFA_Y, -7)
          CFI R24 Frame(CFA_Y, -8)
          CFI CFA_Y Y+8
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        MOVW    R7:R6, R17:R16
//   46   // Se preia valoarea întreagă din pointer
//   47   int16_t x = *((int16_t *)(p));
        MOVW    R31:R30, R7:R6
        LD      R24, Z
        LDD     R25, Z+1
//   48   int16_t index = 0, i = 0;
        LDI     R26, 0
        LDI     R27, 0
        CLR     R4
        CLR     R5
//   49   // Se adaugă prefixul "0x" pentru format hexazecimal
//   50   aux1[index] = '0';
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 48
        ST      Z, R16
//   51   index++;
        ADIW    R27:R26, 1
//   52   aux1[index] = 'x';
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 120
        ST      Z, R16
//   53   index++;
        ADIW    R27:R26, 1
//   54   // Se extrag cifrele hexazecimale în ordine inversă
//   55   do {
//   56     uint8_t a = x & 0x0F;  // Se preiau cei 4 biți cei mai mici
??hexadecimalTransmit_0:
        MOV     R18, R24
        ANDI    R18, 0x0F
//   57     // Se convertește valoarea la caracter ASCII
//   58     if (a <= 9) {
        CPI     R18, 10
        BRCC    ??hexadecimalTransmit_1
//   59       aux2[i] = a + '0';
        MOV     R16, R18
        SUBI    R16, 208
        MOVW    R31:R30, R5:R4
        SUBI    R30, LOW((-(aux2) & 0xFFFF))
        SBCI    R31, (-(aux2) & 0xFFFF) >> 8
        ST      Z, R16
        RJMP    ??hexadecimalTransmit_2
//   60     } else {
//   61       aux2[i] = a + 'A' - 10;
??hexadecimalTransmit_1:
        MOV     R16, R18
        SUBI    R16, 201
        MOVW    R31:R30, R5:R4
        SUBI    R30, LOW((-(aux2) & 0xFFFF))
        SBCI    R31, (-(aux2) & 0xFFFF) >> 8
        ST      Z, R16
//   62     }
//   63     i++;
??hexadecimalTransmit_2:
        LDI     R16, 1
        ADD     R4, R16
        LDI     R16, 0
        ADC     R5, R16
//   64     x >>= 4;  // Se face shiftare pentru următoarea cifră
        LDI     R20, 4
        MOVW    R17:R16, R25:R24
          CFI FunCall ?SS_SHR_L02
        CALL    ?SS_SHR_L02
        MOVW    R25:R24, R17:R16
//   65   } while (x != 0);
        MOV     R16, R24
        OR      R16, R25
        BRNE    ??hexadecimalTransmit_0
//   66   // Se copiază cifrele în ordinea corectă
//   67   for (int16_t j = i - 1; j >= 0; j--) {
        MOVW    R17:R16, R5:R4
        SUBI    R16, 1
        SBCI    R17, 0
??hexadecimalTransmit_3:
        TST     R17
        BRMI    ??hexadecimalTransmit_4
//   68     aux1[index] = aux2[j];
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(aux2) & 0xFFFF))
        SBCI    R31, (-(aux2) & 0xFFFF) >> 8
        LD      R18, Z
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        ST      Z, R18
//   69 
//   70     index++;
        ADIW    R27:R26, 1
//   71   }
        SUBI    R16, 1
        SBCI    R17, 0
        RJMP    ??hexadecimalTransmit_3
//   72   // Se transmite șirul format către modulul USART
//   73   USART_transmit_string(aux1, index);
??hexadecimalTransmit_4:
        MOVW    R19:R18, R27:R26
        LDI     R16, LOW(aux1)
        LDI     R17, (aux1) >> 8
          CFI FunCall USART_transmit_string
        CALL    USART_transmit_string
//   74 }
        LDI     R30, 8
        JMP     ?EPILOGUE_B8_L09
          CFI EndBlock cfiBlock1
//   75 
//   76 // Funcția de transmitere a unui număr de tip double pe serială

        RSEG `CODE`:CODE:NOROOT(1)
//   77 void doubleTransmit(void *p) {
doubleTransmit:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function doubleTransmit
        CODE
        CALL    ?PROLOGUE16_L09
          CFI R15 Frame(CFA_Y, -1)
          CFI R14 Frame(CFA_Y, -2)
          CFI R13 Frame(CFA_Y, -3)
          CFI R12 Frame(CFA_Y, -4)
          CFI R11 Frame(CFA_Y, -5)
          CFI R10 Frame(CFA_Y, -6)
          CFI R9 Frame(CFA_Y, -7)
          CFI R8 Frame(CFA_Y, -8)
          CFI R7 Frame(CFA_Y, -9)
          CFI R6 Frame(CFA_Y, -10)
          CFI R5 Frame(CFA_Y, -11)
          CFI R4 Frame(CFA_Y, -12)
          CFI R27 Frame(CFA_Y, -13)
          CFI R26 Frame(CFA_Y, -14)
          CFI R25 Frame(CFA_Y, -15)
          CFI R24 Frame(CFA_Y, -16)
          CFI CFA_Y Y+16
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        REQUIRE ?Register_R8_is_cg_reg
        REQUIRE ?Register_R9_is_cg_reg
        REQUIRE ?Register_R10_is_cg_reg
        REQUIRE ?Register_R11_is_cg_reg
        REQUIRE ?Register_R12_is_cg_reg
        REQUIRE ?Register_R13_is_cg_reg
        REQUIRE ?Register_R14_is_cg_reg
        REQUIRE ?Register_R15_is_cg_reg
        SBIW    R29:R28, 2
          CFI CFA_Y Y+18
        ST      Y, R16
        STD     Y+1, R17
//   78   // Se preia valoarea double din pointer
//   79   double x = (*(double *)(p));
        LD      R30, Y
        LDD     R31, Y+1
        LD      R8, Z
        LDD     R9, Z+1
        LDD     R10, Z+2
        LDD     R11, Z+3
//   80   int16_t index = 0;
        LDI     R26, 0
        LDI     R27, 0
//   81   int16_t i = 0;
        CLR     R6
        CLR     R7
//   82   // Se tratează cazul numerelor negative
//   83   if (x < 0) {
        MOVW    R17:R16, R9:R8
        MOVW    R19:R18, R11:R10
        LDI     R20, 0
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
          CFI FunCall ?F_CMP_LT_L04
        CALL    ?F_CMP_LT_L04
        BRCC    ??doubleTransmit_0
//   84     aux1[index++] = '-';
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 45
        ST      Z, R16
        ADIW    R27:R26, 1
//   85     x = -x;
        LDI     R16, 128
        EOR     R11, R16
//   86   }
//   87   // Se separă partea întreagă de partea fracționară
//   88   int16_t int_part = (int16_t)x;
??doubleTransmit_0:
        MOVW    R17:R16, R9:R8
        MOVW    R19:R18, R11:R10
          CFI FunCall ?F2SL_L04
        CALL    ?F2SL_L04
        MOVW    R5:R4, R17:R16
//   89   double frac = x - int_part;
        MOVW    R17:R16, R5:R4
        MOV     R18, R17
        LSL     R18
        SBC     R18, R18
        MOV     R19, R18
          CFI FunCall ?SL2F_L04
        CALL    ?SL2F_L04
        MOVW    R21:R20, R17:R16
        MOVW    R23:R22, R19:R18
        MOVW    R17:R16, R9:R8
        MOVW    R19:R18, R11:R10
          CFI FunCall ?F_SUB_L04
        CALL    ?F_SUB_L04
        MOVW    R13:R12, R17:R16
        MOVW    R15:R14, R19:R18
//   90   // Se păstrează două zecimale
//   91   int16_t frac_part = (int16_t)(frac * 100 + 0.5);
        MOVW    R17:R16, R13:R12
        MOVW    R19:R18, R15:R14
        LDI     R20, 0
        LDI     R21, 0
        LDI     R22, 200
        LDI     R23, 66
          CFI FunCall ?F_MUL_L04
        CALL    ?F_MUL_L04
        LDI     R20, 0
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 63
          CFI FunCall ?F_ADD_L04
        CALL    ?F_ADD_L04
          CFI FunCall ?F2SL_L04
        CALL    ?F2SL_L04
        MOVW    R25:R24, R17:R16
//   92   // Se procesează partea întreagă
//   93   if (int_part == 0) {
        MOV     R16, R4
        OR      R16, R5
        BRNE    ??doubleTransmit_1
//   94     aux1[index++] = '0';
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 48
        ST      Z, R16
        ADIW    R27:R26, 1
        RJMP    ??doubleTransmit_2
//   95   } else {
//   96     while (int_part != 0) {
??doubleTransmit_1:
        MOV     R16, R4
        OR      R16, R5
        BREQ    ??doubleTransmit_3
//   97       // Se convertește cifra la caracter ASCII
//   98       uint8_t c = int_part % 10 + '0';
        LDI     R20, 10
        LDI     R21, 0
        MOVW    R17:R16, R5:R4
          CFI FunCall ?SS_DIVMOD_L02
        CALL    ?SS_DIVMOD_L02
        MOV     R18, R20
        SUBI    R18, 208
//   99       // Se stochează temporar în buffer auxiliar
//  100       aux2[i++] = c;
        MOVW    R31:R30, R7:R6
        SUBI    R30, LOW((-(aux2) & 0xFFFF))
        SBCI    R31, (-(aux2) & 0xFFFF) >> 8
        ST      Z, R18
        LDI     R16, 1
        ADD     R6, R16
        LDI     R16, 0
        ADC     R7, R16
//  101       // Se reduce valoarea
//  102       int_part /= 10;
        LDI     R20, 10
        LDI     R21, 0
        MOVW    R17:R16, R5:R4
          CFI FunCall ?SS_DIVMOD_L02
        CALL    ?SS_DIVMOD_L02
        MOVW    R5:R4, R17:R16
        RJMP    ??doubleTransmit_1
//  103     }
//  104     // Se copiază cifrele în ordinea corectă
//  105     for (int16_t j = i - 1; j >= 0; j--) {
??doubleTransmit_3:
        MOVW    R19:R18, R7:R6
        SUBI    R18, 1
        SBCI    R19, 0
??doubleTransmit_4:
        TST     R19
        BRMI    ??doubleTransmit_2
//  106       aux1[index++] = aux2[j];
        MOVW    R31:R30, R19:R18
        SUBI    R30, LOW((-(aux2) & 0xFFFF))
        SBCI    R31, (-(aux2) & 0xFFFF) >> 8
        LD      R16, Z
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        ST      Z, R16
        ADIW    R27:R26, 1
//  107     }
        SUBI    R18, 1
        SBCI    R19, 0
        RJMP    ??doubleTransmit_4
//  108   }
//  109   // Se adaugă separatorul zecimal
//  110   aux1[index++] = '.';
??doubleTransmit_2:
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 46
        ST      Z, R16
        ADIW    R27:R26, 1
//  111   i = 0;
        CLR     R6
        CLR     R7
//  112   // Se procesează partea fracționară
//  113   if (frac_part == 0) {
        MOV     R16, R24
        OR      R16, R25
        BRNE    ??doubleTransmit_5
//  114     aux1[index++] = '0';
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 48
        ST      Z, R16
        ADIW    R27:R26, 1
//  115     aux1[index++] = '0';
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 48
        ST      Z, R16
        ADIW    R27:R26, 1
        RJMP    ??doubleTransmit_6
//  116   }
//  117 
//  118   else {
//  119     if (frac_part < 10) {
??doubleTransmit_5:
        CPI     R24, 10
        LDI     R16, 0
        CPC     R25, R16
        BRGE    ??doubleTransmit_7
//  120       aux1[index++] = '0';  // Se adaugă zeroul pentru o cifră
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 48
        ST      Z, R16
        ADIW    R27:R26, 1
//  121     }
//  122     // Se extrag cifrele fracționare în ordine inversă
//  123     while (frac_part != 0) {
??doubleTransmit_7:
        MOV     R16, R24
        OR      R16, R25
        BREQ    ??doubleTransmit_8
//  124       uint8_t c = frac_part % 10 + '0';
        LDI     R20, 10
        LDI     R21, 0
        MOVW    R17:R16, R25:R24
          CFI FunCall ?SS_DIVMOD_L02
        CALL    ?SS_DIVMOD_L02
        MOV     R18, R20
        SUBI    R18, 208
//  125       aux2[i++] = c;
        MOVW    R31:R30, R7:R6
        SUBI    R30, LOW((-(aux2) & 0xFFFF))
        SBCI    R31, (-(aux2) & 0xFFFF) >> 8
        ST      Z, R18
        LDI     R16, 1
        ADD     R6, R16
        LDI     R16, 0
        ADC     R7, R16
//  126       frac_part /= 10;
        LDI     R20, 10
        LDI     R21, 0
        MOVW    R17:R16, R25:R24
          CFI FunCall ?SS_DIVMOD_L02
        CALL    ?SS_DIVMOD_L02
        MOVW    R25:R24, R17:R16
        RJMP    ??doubleTransmit_7
//  127     }
//  128     // Se copiază cifrele în ordinea corectă
//  129     for (int16_t j = i - 1; j >= 0; j--) {
??doubleTransmit_8:
        MOVW    R19:R18, R7:R6
        SUBI    R18, 1
        SBCI    R19, 0
??doubleTransmit_9:
        TST     R19
        BRMI    ??doubleTransmit_6
//  130       aux1[index++] = aux2[j];
        MOVW    R31:R30, R19:R18
        SUBI    R30, LOW((-(aux2) & 0xFFFF))
        SBCI    R31, (-(aux2) & 0xFFFF) >> 8
        LD      R16, Z
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        ST      Z, R16
        ADIW    R27:R26, 1
//  131     }
        SUBI    R18, 1
        SBCI    R19, 0
        RJMP    ??doubleTransmit_9
//  132   }
//  133   // Se adaugă caracterele de sfârșit de linie
//  134   aux1[index++] = '\n';
??doubleTransmit_6:
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 10
        ST      Z, R16
        ADIW    R27:R26, 1
//  135   aux1[index++] = '\r';
        MOVW    R31:R30, R27:R26
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        LDI     R16, 13
        ST      Z, R16
        ADIW    R27:R26, 1
//  136   // Se transmite șirul format către modulul USART
//  137   USART_transmit_string(aux1, index);
        MOVW    R19:R18, R27:R26
        LDI     R16, LOW(aux1)
        LDI     R17, (aux1) >> 8
          CFI FunCall USART_transmit_string
        CALL    USART_transmit_string
//  138 }
        ADIW    R29:R28, 2
          CFI CFA_Y Y+16
        LDI     R30, 16
        JMP     ?EPILOGUE_B16_L09
          CFI EndBlock cfiBlock2
//  139 // Se transmite un caracter pe serială

        RSEG `CODE`:CODE:NOROOT(1)
//  140 void characterTransmit(void *p) {
characterTransmit:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function characterTransmit
        CODE
        CALL    ?PROLOGUE5_L09
          CFI R4 Frame(CFA_Y, -1)
          CFI R27 Frame(CFA_Y, -2)
          CFI R26 Frame(CFA_Y, -3)
          CFI R25 Frame(CFA_Y, -4)
          CFI R24 Frame(CFA_Y, -5)
          CFI CFA_Y Y+5
        REQUIRE ?Register_R4_is_cg_reg
        MOVW    R27:R26, R17:R16
//  141   // Se preia caracterul din pointer
//  142   int8_t x = (*(int8_t *)(p));
        LD      R4, X
//  143   int16_t index = 0;
        LDI     R24, 0
        LDI     R25, 0
//  144   // Se adaugă caracterul în buffer
//  145   aux1[index++] = x;
        MOVW    R31:R30, R25:R24
        SUBI    R30, LOW((-(aux1) & 0xFFFF))
        SBCI    R31, (-(aux1) & 0xFFFF) >> 8
        ST      Z, R4
        ADIW    R25:R24, 1
//  146   // Se transmite caracterul către modulul USART
//  147   USART_transmit_string(aux1, index);
        MOVW    R19:R18, R25:R24
        LDI     R16, LOW(aux1)
        LDI     R17, (aux1) >> 8
          CFI FunCall USART_transmit_string
        CALL    USART_transmit_string
//  148 }
        LDI     R30, 5
        JMP     ?EPILOGUE_B5_L09
          CFI EndBlock cfiBlock3
//  149 
//  150 // Funcție de tip wrapper prin care se transmit valori de diverse tipuri

        RSEG `CODE`:CODE:NOROOT(1)
//  151 void my_print(Tipuri tip, void *val) {
my_print:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function my_print
        CODE
        CALL    ?PROLOGUE3_L09
          CFI R26 Frame(CFA_Y, -1)
          CFI R25 Frame(CFA_Y, -2)
          CFI R24 Frame(CFA_Y, -3)
          CFI CFA_Y Y+3
        MOV     R26, R16
        MOVW    R25:R24, R19:R18
//  152   switch (tip) {
        MOV     R16, R26
        SUBI    R16, 0
        BREQ    ??my_print_0
        DEC     R16
        BREQ    ??my_print_1
        DEC     R16
        BREQ    ??my_print_2
        DEC     R16
        BREQ    ??my_print_3
        RJMP    ??my_print_4
//  153     case INTEGER:
//  154       // Se transmite un număr întreg
//  155       integerTransmit(val);
??my_print_0:
        MOVW    R17:R16, R25:R24
          CFI FunCall integerTransmit
        RCALL   integerTransmit
//  156       break;
        RJMP    ??my_print_4
//  157     case HEX:
//  158       // Se transmite un număr hexazecimal
//  159       hexadecimalTransmit(val);
??my_print_1:
        MOVW    R17:R16, R25:R24
          CFI FunCall hexadecimalTransmit
        RCALL   hexadecimalTransmit
//  160       break;
        RJMP    ??my_print_4
//  161 
//  162 
//  163     case DOUBLE:
//  164       // Se transmite un număr double
//  165       doubleTransmit(val);
??my_print_2:
        MOVW    R17:R16, R25:R24
          CFI FunCall doubleTransmit
        RCALL   doubleTransmit
//  166       break;
        RJMP    ??my_print_4
//  167     case CHAR:
//  168       // Se transmite un caracter
//  169       characterTransmit(val);
??my_print_3:
        MOVW    R17:R16, R25:R24
          CFI FunCall characterTransmit
        RCALL   characterTransmit
//  170       break;
//  171   }
//  172 }
??my_print_4:
        LDI     R30, 3
        JMP     ?EPILOGUE_B3_L09
          CFI EndBlock cfiBlock4

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,022H
__?EEARH:

        RSEG INITTAB:CODE:NOROOT(0)
        DATA
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DP      0
        REQUIRE ?need_segment_init

        END
// 
// 852 bytes in segment CODE
//   7 bytes in segment INITTAB
//  20 bytes in segment NEAR_Z
// 
// 852 bytes of CODE memory (+ 7 bytes shared)
//  20 bytes of DATA memory
//
//Errors: none
//Warnings: none
