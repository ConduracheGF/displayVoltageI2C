###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       18/Jan/2026  12:23:17
# Copyright 1996-2022 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\main.c
#    Command line =  
#        -f C:\Users\student\AppData\Local\Temp\EWF748.tmp
#        (C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\main.c
#        --cpu=m1280 -ms -o
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\Obj
#        -lC
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\List
#        -lA
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\List
#        -y --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\List\main.lst
#    Object file  =  
#        C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\Debug\Obj\main.r90
#
###############################################################################

C:\Users\student\Downloads\displayVoltageI2C-20260118T071946Z-1-001\displayVoltageI2C\cod\main.c
      1          #include <intrinsics.h>
      2          #include <ioavr.h>

   \                                 In  segment ABSOLUTE, at 0xbc
   \   union <unnamed> volatile __io _A_TWCR
   \                     _A_TWCR:
   \   00000000                      DS8 1
      3          #include <stdint.h>
      4          #include <stdbool.h>
      5          
      6          #include "functii_i2c.h"
      7          #include "usart_control.h"
      8          #include "usart_my_lib.h"
      9          #include "functii_adc.h"
     10          #include "functii_afisare.h"
     11          #include "functii_timer.h"
     12          
     13          /*
     14          
     15          typedef enum {
     16              SYSTEM_OK,
     17              SYSTEM_ERROR
     18          } system_status_t;
     19          
     20          static system_status_t system_status = SYSTEM_OK;
     21          
     22          int main(void) {
     23              ADC_Init();
     24              i2c_init();
     25              USART_initialize(BAUD_RATE);
     26              Timer0_Init();
     27              
     28              __enable_interrupt();
     29          
     30              uint16_t valoare_curenta = 0;
     31          
     32              while (1) {
     33                  // Ruleaza masina de stari ADC (Pornire -> Convert -> Filtrare)
     34                  // Trebuie sa fie in afara timerului pentru a avea media FIR gata rapid
     35                  ADC_Task_Run();
     36                  
     37                  // Ruleaza masina de stari USART (Trimite octetii din buffer pe rand)
     38                  USART_Task_Run();
     39          
     40                  if (Timer_Check_20ms()) {
     41                      
     42                      // Verificam daca ADC-ul a finalizat calculul mediei
     43                      if (ADC_Is_Data_Ready()) {
     44                          valoare_curenta = ADC_Get_Filtered_Value();
     45          
     46                          // Nu mai folosim USART_Is_Ready() pentru a nu sari peste valori
     47                          my_print(INTEGER, &valoare_curenta);
     48          
     49                          // Verificam daca magistrala nu este blocata inainte de a trimite
     50                          if (!i2c_is_busy()) {
     51                              Display_Task_Run(valoare_curenta);
     52                          }
     53                      }
     54          
     55                      // Daca I2C raporteaza eroare, sistemul trece in status ERROR
     56                      if (Display_Is_Error()) {
     57                          system_status = SYSTEM_ERROR;
     58                      } else {
     59                          system_status = SYSTEM_OK;
     60                      }
     61                  }
     62              }
     63          }
     64          
     65          */
     66          
     67          extern volatile i2c_state_t g_i2c_state; 
     68          

   \                                 In  segment CODE, align 2, keep-with-next
     69          void main(void) {
   \                     main:
   \   00000000   938A               ST      -Y, R24
   \   00000002   97E0               SBIW    R29:R28, 48
     70              // 1. Initializari Hardware
     71              i2c_init();
   \   00000004   ........           CALL    i2c_init
     72              Timer0_Init();
   \   00000008   ........           CALL    Timer0_Init
     73              __enable_interrupt();
   \   0000000C   9478               SEI
     74          
     75              // 2. Initializare Driver Afisaj (asteptam pana reuseste)
     76              while(setup_7_segm() != SEND_SUCCESSFUL) {
   \                     ??main_0:
   \   0000000E   ........           CALL    setup_7_segm
   \   00000012   2300               TST     R16
   \   00000014   F051               BREQ    ??main_1
     77                  // Daca nu reuseste, resetam variabila de stare pentru a reincerca
     78                  g_i2c_state = I2C_STATE_IDLE;
   \   00000016   E000               LDI     R16, 0
   \   00000018   9300....           STS     g_i2c_state, R16
     79                  delay_milisecunde(10); 
   \   0000001C   E00A               LDI     R16, 10
   \   0000001E   E010               LDI     R17, 0
   \   00000020   E020               LDI     R18, 0
   \   00000022   E030               LDI     R19, 0
   \   00000024   ........           CALL    delay_milisecunde
   \   00000028   CFF2               RJMP    ??main_0
     80              }
     81          
     82              // 3. Datele de test
     83              uint16_t valori[] = {3245, 3976, 2578, 1234, 1678, 2345, 3456, 4567, 3245, 3976, 2578, 1234, 1678, 2345, 3456, 4567, 3245, 3976, 2578, 1234, 1678, 2345, 3456, 4567};
   \                     ??main_1:
   \   0000002A   018E               MOVW    R17:R16, R29:R28
   \   0000002C   ....               LDI     R30, LOW(`?<Constant {3245, 3976, 2578, 1234, 1678, 2345`)
   \   0000002E   ....               LDI     R31, HIGH(`?<Constant {3245, 3976, 2578, 1234, 1678, 2345`)
   \   00000030   ....               LDI     R19, (`?<Constant {3245, 3976, 2578, 1234, 1678, 2345`) >> 16
   \   00000032   E340               LDI     R20, 48
   \   00000034   E050               LDI     R21, 0
   \   00000036   ........           CALL    ?ML_FLASH_SRAM_24EC_16_L07
     84              uint8_t index = 0;
   \   0000003A   E080               LDI     R24, 0
     85          
     86              while (1) {
     87                  // Verificam daca a trecut timpul setat in Timer_Check (ex: 500ms)
     88                  if (Timer_Check()) {
   \                     ??main_2:
   \   0000003C   ........           CALL    Timer_Check
   \   00000040   2300               TST     R16
   \   00000042   F3E1               BREQ    ??main_2
     89                      
     90                      // Verificam daca masina de stari I2C este libera
     91                      if (!i2c_is_busy()) {
   \   00000044   ........           CALL    i2c_is_busy
   \   00000048   2300               TST     R16
   \   0000004A   F481               BRNE    ??main_3
     92                          // Trimitem valoarea la afisaj
     93                          afisare_tensiune(valori[index]);
   \   0000004C   01FE               MOVW    R31:R30, R29:R28
   \   0000004E   2F08               MOV     R16, R24
   \   00000050   E010               LDI     R17, 0
   \   00000052   0F00               LSL     R16
   \   00000054   1F11               ROL     R17
   \   00000056   0FE0               ADD     R30, R16
   \   00000058   1FF1               ADC     R31, R17
   \   0000005A   8100               LD      R16, Z
   \   0000005C   8111               LDD     R17, Z+1
   \   0000005E   ........           CALL    afisare_tensiune
     94                          
     95                          // Trecem la urmatoarea valoare din vector
     96                          index++;
   \   00000062   9583               INC     R24
     97                          if (index >= 24) index = 0;
   \   00000064   3188               CPI     R24, 24
   \   00000066   F350               BRCS    ??main_2
   \   00000068   E080               LDI     R24, 0
   \   0000006A   CFE8               RJMP    ??main_2
     98                      } 
     99                      else {
    100                          /* LOGICA DE DEBLOCARE (Safety Net):
    101                             Daca am intrat aici, inseamna ca Timer_Check() a zis "e timpul", 
    102                             dar I2C-ul este inca blocat de la transmisia anterioara.
    103                          */
    104                          
    105                          // Reset Hardware: Trimitem un semnal STOP fortat pe fire
    106                          TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO); 
   \                     ??main_3:
   \   0000006C   E904               LDI     R16, 148
   \   0000006E   9300....           STS     _A_TWCR, R16
    107                          
    108                          // Reset Software: Spunem codului ca magistrala este acum IDLE
    109                          g_i2c_state = I2C_STATE_IDLE; 
   \   00000072   E000               LDI     R16, 0
   \   00000074   9300....           STS     g_i2c_state, R16
   \   00000078   CFE1               RJMP    ??main_2
   \   0000007A                      REQUIRE _A_TWCR
    110                      }
    111                  }
    112                  
    113                  // Aici poti adauga si alte task-uri (ex: ADC_Task_Run() sau USART_Task_Run())
    114              }
    115          }

   \                                 In  segment FAR_F, align 1, keep-with-next
   \                     `?<Constant {3245, 3976, 2578, 1234, 1678, 2345`:
   \   00000000   0CAD0F880A12       DC16 3245, 3976, 2578, 1234, 1678, 2345, 3456, 4567, 3245, 3976, 2578
   \              04D2068E0929
   \              0D8011D70CAD
   \              0F880A12    
   \   00000016   04D2068E0929       DC16 1234, 1678, 2345, 3456, 4567, 3245, 3976, 2578, 1234, 1678, 2345
   \              0D8011D70CAD
   \              0F880A1204D2
   \              068E0929    
   \   0000002C   0D8011D7           DC16 3456, 4567

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
     49      2   main
       49      2   -> Timer0_Init
       49      2   -> Timer_Check
       49      2   -> afisare_tensiune
       49      2   -> delay_milisecunde
       49      2   -> i2c_init
       49      2   -> i2c_is_busy
       49      2   -> setup_7_segm
       49      2 ?ML_FLASH_SRAM_24EC_16_L07


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      48  ?<Constant {3245, 3976, 2578, 1234, 1678, 2345
       1  _A_TWCR
     122  main

 
   1 byte  in segment ABSOLUTE
 122 bytes in segment CODE
  48 bytes in segment FAR_F
 
 170 bytes of CODE memory
   0 bytes of DATA memory (+ 1 byte shared)

Errors: none
Warnings: none
