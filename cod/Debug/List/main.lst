###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       15/Jan/2026  22:50:42
# Copyright 1996-2022 IAR Systems AB.
#
#    Source file  =  C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\main.c
#    Command line =  
#        -f C:\Users\vboxuser\AppData\Local\Temp\EWB94B.tmp
#        (C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\main.c --cpu=m1280
#        -ms -o C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\Obj -lC
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -lA
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List\main.lst
#    Object file  =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\Obj\main.r90
#
###############################################################################

C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\main.c
      1          #include <intrinsics.h>
      2          #include <ioavr.h>
      3          #include <stdint.h>
      4          #include <stdbool.h>
      5          
      6          #include "functii_i2c.h"
      7          #include "usart_control.h"
      8          #include "usart_my_lib.h"
      9          #include "functii_adc.h"
     10          #include "functii_afisare.h"
     11          #include "functii_timer.h"
     12          
     13          typedef enum {
     14            SYSTEM_OK,
     15            SYSTEM_ERROR
     16          } system_status_t;
     17          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     18          static system_status_t system_status = SYSTEM_OK;
                                        ^
Warning[Pe550]: variable "system_status" was set but never used
   \                     system_status:
   \   00000000                      DS8 1
     19          

   \                                 In  segment CODE, align 2, keep-with-next
     20          int main(void) {
   \                     main:
   \   00000000   9722               SBIW    R29:R28, 2
     21              
     22              // Initializare ADC (configurare registre, fara start conversie)
     23              ADC_Init();
   \   00000002   ........           CALL    ADC_Init
     24              
     25              // Initializare I2C pentru comunicarea cu driverul de display
     26              i2c_init();
   \   00000006   ........           CALL    i2c_init
     27              
     28              // Initializare USART cu Baud Rate calculat (9600 bps)
     29              USART_initialize(BAUD_RATE);
   \   0000000A   E607               LDI     R16, 103
   \   0000000C   E010               LDI     R17, 0
   \   0000000E   ........           CALL    USART_initialize
     30              
     31              // Initializare Timer0 pentru baza de timp de 1ms
     32              Timer0_Init();
   \   00000012   ........           CALL    Timer0_Init
     33              
     34              // Activare globala a intreruperilor (necesar pentru I2C, USART si Timer)
     35              __enable_interrupt();
   \   00000016   9478               SEI
     36          
     37              // Variabila locala pentru a stoca valoarea de afisat/trimis
     38              uint16_t valoare_curenta = 0;
   \   00000018   E000               LDI     R16, 0
   \   0000001A   8308               ST      Y, R16
   \   0000001C   E000               LDI     R16, 0
   \   0000001E   8309               STD     Y+1, R16
     39          
     40              while (1) {
     41                  
     42                  // Verificam daca au trecut 20ms (bataia inimii a sistemului)
     43                  if (Timer_Check_20ms()) {
   \                     ??main_0:
   \   00000020   ........           CALL    Timer_Check_20ms
   \   00000024   2300               TST     R16
   \   00000026   F109               BREQ    ??main_1
     44                      
     45                      // Management ADC: 
     46                      // Task-ul gestioneaza singur Starile: Pornire -> Asteptare -> Citire -> Filtrare FIR
     47                      ADC_Task_Run();
   \   00000028   ........           CALL    ADC_Task_Run
     48                      
     49                      // Verificam daca avem date noi de la ADC
     50                      if (ADC_Is_Data_Ready()) {
   \   0000002C   ........           CALL    ADC_Is_Data_Ready
   \   00000030   2300               TST     R16
   \   00000032   F081               BREQ    ??main_2
     51                          
     52                          // Preluam valoarea filtrata (media ultimelor 8 masuratori)
     53                          valoare_curenta = ADC_Get_Filtered_Value();
   \   00000034   ........           CALL    ADC_Get_Filtered_Value
   \   00000038   8308               ST      Y, R16
   \   0000003A   8319               STD     Y+1, R17
     54                          
     55                          // Management Display:
     56                          // Trimite datele catre AS1115 via I2C. 
     57                          // Daca I2C-ul este ocupat sau da eroare, task-ul va incerca sa re-initializeze driverul.
     58                          Display_Task_Run(valoare_curenta);
   \   0000003C   8108               LD      R16, Y
   \   0000003E   8119               LDD     R17, Y+1
   \   00000040   ........           CALL    Display_Task_Run
     59                          
     60                          // Management USART (State Machine):
     61                          // Trimitem pe seriala doar daca masina de stari USART este in IDLE 
     62                          // (adica bufferul circular de transmisie a fost golit anterior)
     63                          if (USART_Is_Ready()) {
   \   00000044   ........           CALL    USART_Is_Ready
   \   00000048   2300               TST     R16
   \   0000004A   F021               BREQ    ??main_2
     64                              my_print(INTEGER, &valoare_curenta);
   \   0000004C   019E               MOVW    R19:R18, R29:R28
   \   0000004E   E000               LDI     R16, 0
   \   00000050   ........           CALL    my_print
     65                          }
     66                      }
     67                      
     68                      // Verificare Siguranta:
     69                      // Daca driverul de afisare raporteaza erori critice repetate
     70                      if (Display_Is_Error()) {
   \                     ??main_2:
   \   00000054   ........           CALL    Display_Is_Error
   \   00000058   2300               TST     R16
   \   0000005A   F021               BREQ    ??main_3
     71                          system_status = SYSTEM_ERROR;
   \   0000005C   E001               LDI     R16, 1
   \   0000005E   9300....           STS     system_status, R16
   \   00000062   C003               RJMP    ??main_1
     72                      } else {
     73                          system_status = SYSTEM_OK;
   \                     ??main_3:
   \   00000064   E000               LDI     R16, 0
   \   00000066   9300....           STS     system_status, R16
     74                      }
     75                  }
     76                  
     77                  // Task-uri de fundal:
     78                  // Acestea ruleaza cat mai des posibil (in afara if-ului de 20ms) 
     79                  // pentru a procesa cozile de date sau flag-urile de hardware.
     80                  USART_Task_Run(); 
   \                     ??main_1:
   \   0000006A   ........           CALL    USART_Task_Run
   \   0000006E   CFD8               RJMP    ??main_0
     81              }
     82          }

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      2      2   main
        2      2   -> ADC_Get_Filtered_Value
        2      2   -> ADC_Init
        2      2   -> ADC_Is_Data_Ready
        2      2   -> ADC_Task_Run
        2      2   -> Display_Is_Error
        2      2   -> Display_Task_Run
        2      2   -> Timer0_Init
        2      2   -> Timer_Check_20ms
        2      2   -> USART_Is_Ready
        2      2   -> USART_Task_Run
        2      2   -> USART_initialize
        2      2   -> i2c_init
        2      2   -> my_print


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     112  main
       1  system_status
       7  -- Other

 
 112 bytes in segment CODE
   7 bytes in segment INITTAB
   1 byte  in segment NEAR_Z
 
 112 bytes of CODE memory (+ 7 bytes shared)
   1 byte  of DATA memory

Errors: none
Warnings: 1
