###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       15/Jan/2026  22:09:07
# Copyright 1996-2022 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\usart_round_buff.c
#    Command line =  
#        -f C:\Users\vboxuser\AppData\Local\Temp\EWCCBB.tmp
#        (C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\usart_round_buff.c
#        --cpu=m1280 -ms -o
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\Obj -lC
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -lA
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\List\usart_round_buff.lst
#    Object file  =  
#        C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\Debug\Obj\usart_round_buff.r90
#
###############################################################################

C:\Users\vboxuser\Desktop\displayVoltageI2C\cod\usart_round_buff.c
      1          #include "usart_round_buff.h"
      2          
      3          // Funcție folosită pentru adăugarea unui caracter în bufferul circular

   \                                 In  segment CODE, align 2, keep-with-next
      4          int16_t push(round_buff_s *inBuffer, uint8_t data) {
   \                     `push`:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01D8               MOVW    R27:R26, R17:R16
   \   00000006   2F82               MOV     R24, R18
      5            /*
      6            * Se calculează poziția următoare a indicelui head folosind operația
      7            * modulo pentru comportament circular.
      8            */
      9            uint8_t next_head = (inBuffer->head + 1) % BUFFER_SIZE;
   \   00000008   01FD               MOVW    R31:R30, R27:R26
   \   0000000A   8900               LDD     R16, Z+16
   \   0000000C   E010               LDI     R17, 0
   \   0000000E   5F0F               SUBI    R16, 255
   \   00000010   4F1F               SBCI    R17, 255
   \   00000012   E140               LDI     R20, 16
   \   00000014   E050               LDI     R21, 0
   \   00000016   ........           CALL    ?SS_DIVMOD_L02
   \   0000001A   2F94               MOV     R25, R20
     10            /*
     11            * Dacă bufferul nu este plin, se inserează caracterul și
     12            * se actualizează indicele head.
     13            */
     14            if (!is_full(inBuffer)) {
   \   0000001C   018D               MOVW    R17:R16, R27:R26
   \   0000001E   ....               RCALL   is_full
   \   00000020   2B01               OR      R16, R17
   \   00000022   F461               BRNE    ??push_0
     15              inBuffer->buffer[inBuffer->head] = data;
   \   00000024   01FD               MOVW    R31:R30, R27:R26
   \   00000026   8900               LDD     R16, Z+16
   \   00000028   E010               LDI     R17, 0
   \   0000002A   01FD               MOVW    R31:R30, R27:R26
   \   0000002C   0FE0               ADD     R30, R16
   \   0000002E   1FF1               ADC     R31, R17
   \   00000030   8380               ST      Z, R24
     16              inBuffer->head = next_head;
   \   00000032   01FD               MOVW    R31:R30, R27:R26
   \   00000034   8B90               STD     Z+16, R25
     17              // Returnează 1 pentru succes
     18              return 1;
   \   00000036   E001               LDI     R16, 1
   \   00000038   E010               LDI     R17, 0
   \   0000003A   C002               RJMP    ??push_1
     19            } else
     20              // Returnează 0 dacă bufferul este plin
     21              return 0;
   \                     ??push_0:
   \   0000003C   E000               LDI     R16, 0
   \   0000003E   E010               LDI     R17, 0
   \                     ??push_1:
   \   00000040   E0E4               LDI     R30, 4
   \   00000042   ........           JMP     ?EPILOGUE_B4_L09
     22          }
     23          
     24          // Funcție folosită pentru extragerea unui caracter din buffer

   \                                 In  segment CODE, align 2, keep-with-next
     25          uint8_t pop(round_buff_s *inBuffer) {
   \                     `pop`:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   01D8               MOVW    R27:R26, R17:R16
     26            /*
     27            * Dacă bufferul nu este gol, se preia caracterul din poziția tail
     28            * și se actualizează indicele tail pentru comportament circular.
     29            */
     30            if (!is_empty(inBuffer)) {
   \   00000006   018D               MOVW    R17:R16, R27:R26
   \   00000008   ....               RCALL   is_empty
   \   0000000A   2B01               OR      R16, R17
   \   0000000C   F4A1               BRNE    ??pop_0
     31              uint8_t data = inBuffer->buffer[inBuffer->tail];
   \   0000000E   01FD               MOVW    R31:R30, R27:R26
   \   00000010   8901               LDD     R16, Z+17
   \   00000012   E010               LDI     R17, 0
   \   00000014   01FD               MOVW    R31:R30, R27:R26
   \   00000016   0FE0               ADD     R30, R16
   \   00000018   1FF1               ADC     R31, R17
   \   0000001A   8120               LD      R18, Z
     32              inBuffer->tail = (inBuffer->tail + 1) % BUFFER_SIZE;
   \   0000001C   01FD               MOVW    R31:R30, R27:R26
   \   0000001E   8901               LDD     R16, Z+17
   \   00000020   E010               LDI     R17, 0
   \   00000022   5F0F               SUBI    R16, 255
   \   00000024   4F1F               SBCI    R17, 255
   \   00000026   E140               LDI     R20, 16
   \   00000028   E050               LDI     R21, 0
   \   0000002A   ........           CALL    ?SS_DIVMOD_L02
   \   0000002E   01FD               MOVW    R31:R30, R27:R26
   \   00000030   8B41               STD     Z+17, R20
     33              // Returnează caracterul extras
     34              return data;
   \   00000032   2F02               MOV     R16, R18
   \   00000034   C001               RJMP    ??pop_1
     35            } else {
     36              // Returnează 0 dacă bufferul este gol
     37              return 0;
   \                     ??pop_0:
   \   00000036   E000               LDI     R16, 0
   \                     ??pop_1:
   \   00000038   91A9               LD      R26, Y+
   \   0000003A   91B9               LD      R27, Y+
   \   0000003C   9508               RET
     38            }
     39          }
     40          
     41          // Funcție folosită pentru adăugarea unui șir de caractere în buffer

   \                                 In  segment CODE, align 2, keep-with-next
     42          int16_t push_vec(round_buff_s *inBuffer, uint8_t data[], int16_t length) {
   \                     push_vec:
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004   0128               MOVW    R5:R4, R17:R16
   \   00000006   0139               MOVW    R7:R6, R19:R18
   \   00000008   01DA               MOVW    R27:R26, R21:R20
     43            int16_t i;
     44            /*
     45            * Se parcurge fiecare caracter din șir și se încearcă adăugarea lui.
     46            * În caz că bufferul se umple, se oprește inserarea.
     47            */
     48            for (i = 0; i < length; i++) {
   \   0000000A   E080               LDI     R24, 0
   \   0000000C   E090               LDI     R25, 0
   \                     ??push_vec_0:
   \   0000000E   178A               CP      R24, R26
   \   00000010   079B               CPC     R25, R27
   \   00000012   F454               BRGE    ??push_vec_1
     49              uint8_t verif = push(inBuffer, data[i]);
   \   00000014   01F3               MOVW    R31:R30, R7:R6
   \   00000016   0FE8               ADD     R30, R24
   \   00000018   1FF9               ADC     R31, R25
   \   0000001A   8120               LD      R18, Z
   \   0000001C   0182               MOVW    R17:R16, R5:R4
   \   0000001E   ....               RCALL   `push`
     50              if (verif == 0)
   \   00000020   2300               TST     R16
   \   00000022   F011               BREQ    ??push_vec_1
     51                break;
     52            }
   \   00000024   9601               ADIW    R25:R24, 1
   \   00000026   CFF3               RJMP    ??push_vec_0
     53          
     54            // Returnează numărul de caractere adăugate cu succes
     55            return i;
   \                     ??push_vec_1:
   \   00000028   018C               MOVW    R17:R16, R25:R24
   \   0000002A   E0E8               LDI     R30, 8
   \   0000002C   ........           JMP     ?EPILOGUE_B8_L09
     56          }
     57          
     58          // Funcție folosită pentru verificarea dacă bufferul este gol

   \                                 In  segment CODE, align 2, keep-with-next
     59          int16_t is_empty(round_buff_s *inBuffer) {
   \                     is_empty:
     60            return (inBuffer->head == inBuffer->tail);
   \   00000000   01F8               MOVW    R31:R30, R17:R16
   \   00000002   8920               LDD     R18, Z+16
   \   00000004   01F8               MOVW    R31:R30, R17:R16
   \   00000006   8901               LDD     R16, Z+17
   \   00000008   1720               CP      R18, R16
   \   0000000A   F411               BRNE    ??is_empty_0
   \   0000000C   E001               LDI     R16, 1
   \   0000000E   C001               RJMP    ??is_empty_1
   \                     ??is_empty_0:
   \   00000010   E000               LDI     R16, 0
   \                     ??is_empty_1:
   \   00000012   E010               LDI     R17, 0
   \   00000014   9508               RET
     61          }
     62          
     63          // Funcție folosită pentru verificarea dacă bufferul este plin

   \                                 In  segment CODE, align 2, keep-with-next
     64          int16_t is_full(round_buff_s *inBuffer) {
   \                     is_full:
   \   00000000   2F3B               MOV     R19, R27
   \   00000002   2F6A               MOV     R22, R26
   \   00000004   01D8               MOVW    R27:R26, R17:R16
     65            return ((inBuffer->head + 1) % BUFFER_SIZE) == inBuffer->tail;
   \   00000006   9650               ADIW    R27:R26, 16
   \   00000008   910C               LD      R16, X
   \   0000000A   9750               SBIW    R27:R26, 16
   \   0000000C   E010               LDI     R17, 0
   \   0000000E   5F0F               SUBI    R16, 255
   \   00000010   4F1F               SBCI    R17, 255
   \   00000012   E140               LDI     R20, 16
   \   00000014   E050               LDI     R21, 0
   \   00000016   ........           CALL    ?SS_DIVMOD_L02
   \   0000001A   9651               ADIW    R27:R26, 17
   \   0000001C   910C               LD      R16, X
   \   0000001E   9751               SBIW    R27:R26, 17
   \   00000020   E010               LDI     R17, 0
   \   00000022   1740               CP      R20, R16
   \   00000024   0751               CPC     R21, R17
   \   00000026   F411               BRNE    ??is_full_0
   \   00000028   E001               LDI     R16, 1
   \   0000002A   C001               RJMP    ??is_full_1
   \                     ??is_full_0:
   \   0000002C   E000               LDI     R16, 0
   \                     ??is_full_1:
   \   0000002E   E010               LDI     R17, 0
   \   00000030   2FA6               MOV     R26, R22
   \   00000032   2FB3               MOV     R27, R19
   \   00000034   9508               RET
     66          }

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   is_empty
      0      2   is_full
        0      2 ?SS_DIVMOD_L02
      2      2   pop
        2      2   -> is_empty
        2      2 ?SS_DIVMOD_L02
      4      2   push
        4      2   -> is_full
        4      2 ?SS_DIVMOD_L02
      8      2   push_vec
        8      2   -> push


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      22  is_empty
      54  is_full
      62  pop
      70  push
      48  push_vec

 
 256 bytes in segment CODE
 
 256 bytes of CODE memory

Errors: none
Warnings: none
