###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       16/Jan/2026  17:06:00
# Copyright 1996-2022 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\usart_round_buff.c
#    Command line =  
#        -f C:\Users\STUDEN~1.DES\AppData\Local\Temp\EW88B4.tmp
#        (C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\usart_round_buff.c
#        --cpu=m1280 -ms -o
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\Obj
#        -lC
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\List
#        -lA
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\List
#        -y --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e --eeprom_size 4096 --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On)
#    Locale       =  English_GBR.1252
#    List file    =  
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\List\usart_round_buff.lst
#    Object file  =  
#        C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\Debug\Obj\usart_round_buff.r90
#
###############################################################################

C:\Users\student.DESKTOP-NIC452T\Downloads\displayVoltageI2C\displayVoltageI2C\cod\usart_round_buff.c
      1          #include "usart_round_buff.h"
      2          
      3          // Funcție folosită pentru adăugarea unui caracter în bufferul circular

   \                                 In  segment CODE, align 2, keep-with-next
      4          int16_t push(round_buff_s *inBuffer, uint8_t data) {
   \                     `push`:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   2FA2               MOV     R26, R18
      5            /*
      6            * Se calculează poziția următoare a indicelui head folosind operația
      7            * modulo pentru comportament circular.
      8            */
      9            uint8_t next_head = (inBuffer->head + 1) % BUFFER_SIZE;
   \   00000008   01FC               MOVW    R31:R30, R25:R24
   \   0000000A   5CE0               SUBI    R30, 192
   \   0000000C   4FFF               SBCI    R31, 255
   \   0000000E   8100               LD      R16, Z
   \   00000010   E010               LDI     R17, 0
   \   00000012   5F0F               SUBI    R16, 255
   \   00000014   4F1F               SBCI    R17, 255
   \   00000016   E440               LDI     R20, 64
   \   00000018   E050               LDI     R21, 0
   \   0000001A   ........           CALL    ?SS_DIVMOD_L02
   \   0000001E   2FB4               MOV     R27, R20
     10            /*
     11            * Dacă bufferul nu este plin, se inserează caracterul și
     12            * se actualizează indicele head.
     13            */
     14            if (!is_full(inBuffer)) {
   \   00000020   018C               MOVW    R17:R16, R25:R24
   \   00000022   ....               RCALL   is_full
   \   00000024   2B01               OR      R16, R17
   \   00000026   F481               BRNE    ??push_0
     15              inBuffer->buffer[inBuffer->head] = data;
   \   00000028   01FC               MOVW    R31:R30, R25:R24
   \   0000002A   5CE0               SUBI    R30, 192
   \   0000002C   4FFF               SBCI    R31, 255
   \   0000002E   8100               LD      R16, Z
   \   00000030   E010               LDI     R17, 0
   \   00000032   01FC               MOVW    R31:R30, R25:R24
   \   00000034   0FE0               ADD     R30, R16
   \   00000036   1FF1               ADC     R31, R17
   \   00000038   83A0               ST      Z, R26
     16              inBuffer->head = next_head;
   \   0000003A   01FC               MOVW    R31:R30, R25:R24
   \   0000003C   5CE0               SUBI    R30, 192
   \   0000003E   4FFF               SBCI    R31, 255
   \   00000040   83B0               ST      Z, R27
     17              // Returnează 1 pentru succes
     18              return 1;
   \   00000042   E001               LDI     R16, 1
   \   00000044   E010               LDI     R17, 0
   \   00000046   C002               RJMP    ??push_1
     19            } else
     20              // Returnează 0 dacă bufferul este plin
     21              return 0;
   \                     ??push_0:
   \   00000048   E000               LDI     R16, 0
   \   0000004A   E010               LDI     R17, 0
   \                     ??push_1:
   \   0000004C   E0E4               LDI     R30, 4
   \   0000004E   ........           JMP     ?EPILOGUE_B4_L09
     22          }
     23          
     24          // Funcție folosită pentru extragerea unui caracter din buffer

   \                                 In  segment CODE, align 2, keep-with-next
     25          uint8_t pop(round_buff_s *inBuffer) {
   \                     `pop`:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   01C8               MOVW    R25:R24, R17:R16
     26            /*
     27            * Dacă bufferul nu este gol, se preia caracterul din poziția tail
     28            * și se actualizează indicele tail pentru comportament circular.
     29            */
     30            if (!is_empty(inBuffer)) {
   \   00000006   018C               MOVW    R17:R16, R25:R24
   \   00000008   ....               RCALL   is_empty
   \   0000000A   2B01               OR      R16, R17
   \   0000000C   F4D1               BRNE    ??pop_0
     31              uint8_t data = inBuffer->buffer[inBuffer->tail];
   \   0000000E   01FC               MOVW    R31:R30, R25:R24
   \   00000010   5BEF               SUBI    R30, 191
   \   00000012   4FFF               SBCI    R31, 255
   \   00000014   8100               LD      R16, Z
   \   00000016   E010               LDI     R17, 0
   \   00000018   01FC               MOVW    R31:R30, R25:R24
   \   0000001A   0FE0               ADD     R30, R16
   \   0000001C   1FF1               ADC     R31, R17
   \   0000001E   8120               LD      R18, Z
     32              inBuffer->tail = (inBuffer->tail + 1) % BUFFER_SIZE;
   \   00000020   01FC               MOVW    R31:R30, R25:R24
   \   00000022   5BEF               SUBI    R30, 191
   \   00000024   4FFF               SBCI    R31, 255
   \   00000026   8100               LD      R16, Z
   \   00000028   E010               LDI     R17, 0
   \   0000002A   5F0F               SUBI    R16, 255
   \   0000002C   4F1F               SBCI    R17, 255
   \   0000002E   E440               LDI     R20, 64
   \   00000030   E050               LDI     R21, 0
   \   00000032   ........           CALL    ?SS_DIVMOD_L02
   \   00000036   01FC               MOVW    R31:R30, R25:R24
   \   00000038   5BEF               SUBI    R30, 191
   \   0000003A   4FFF               SBCI    R31, 255
   \   0000003C   8340               ST      Z, R20
     33              // Returnează caracterul extras
     34              return data;
   \   0000003E   2F02               MOV     R16, R18
   \   00000040   C001               RJMP    ??pop_1
     35            } else {
     36              // Returnează 0 dacă bufferul este gol
     37              return 0;
   \                     ??pop_0:
   \   00000042   E000               LDI     R16, 0
   \                     ??pop_1:
   \   00000044   9189               LD      R24, Y+
   \   00000046   9199               LD      R25, Y+
   \   00000048   9508               RET
     38            }
     39          }
     40          
     41          // Funcție folosită pentru adăugarea unui șir de caractere în buffer

   \                                 In  segment CODE, align 2, keep-with-next
     42          int16_t push_vec(round_buff_s *inBuffer, uint8_t data[], int16_t length) {
   \                     push_vec:
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004   0128               MOVW    R5:R4, R17:R16
   \   00000006   0139               MOVW    R7:R6, R19:R18
   \   00000008   01DA               MOVW    R27:R26, R21:R20
     43            int16_t i;
     44            /*
     45            * Se parcurge fiecare caracter din șir și se încearcă adăugarea lui.
     46            * În caz că bufferul se umple, se oprește inserarea.
     47            */
     48            for (i = 0; i < length; i++) {
   \   0000000A   E080               LDI     R24, 0
   \   0000000C   E090               LDI     R25, 0
   \                     ??push_vec_0:
   \   0000000E   178A               CP      R24, R26
   \   00000010   079B               CPC     R25, R27
   \   00000012   F454               BRGE    ??push_vec_1
     49              uint8_t verif = push(inBuffer, data[i]);
   \   00000014   01F3               MOVW    R31:R30, R7:R6
   \   00000016   0FE8               ADD     R30, R24
   \   00000018   1FF9               ADC     R31, R25
   \   0000001A   8120               LD      R18, Z
   \   0000001C   0182               MOVW    R17:R16, R5:R4
   \   0000001E   ....               RCALL   `push`
     50              if (verif == 0)
   \   00000020   2300               TST     R16
   \   00000022   F011               BREQ    ??push_vec_1
     51                break;
     52            }
   \   00000024   9601               ADIW    R25:R24, 1
   \   00000026   CFF3               RJMP    ??push_vec_0
     53          
     54            // Returnează numărul de caractere adăugate cu succes
     55            return i;
   \                     ??push_vec_1:
   \   00000028   018C               MOVW    R17:R16, R25:R24
   \   0000002A   E0E8               LDI     R30, 8
   \   0000002C   ........           JMP     ?EPILOGUE_B8_L09
     56          }
     57          
     58          // Funcție folosită pentru verificarea dacă bufferul este gol

   \                                 In  segment CODE, align 2, keep-with-next
     59          int16_t is_empty(round_buff_s *inBuffer) {
   \                     is_empty:
     60            return (inBuffer->head == inBuffer->tail);
   \   00000000   01F8               MOVW    R31:R30, R17:R16
   \   00000002   5CE0               SUBI    R30, 192
   \   00000004   4FFF               SBCI    R31, 255
   \   00000006   8120               LD      R18, Z
   \   00000008   5B0F               SUBI    R16, 191
   \   0000000A   4F1F               SBCI    R17, 255
   \   0000000C   01F8               MOVW    R31:R30, R17:R16
   \   0000000E   8100               LD      R16, Z
   \   00000010   1720               CP      R18, R16
   \   00000012   F411               BRNE    ??is_empty_0
   \   00000014   E001               LDI     R16, 1
   \   00000016   C001               RJMP    ??is_empty_1
   \                     ??is_empty_0:
   \   00000018   E000               LDI     R16, 0
   \                     ??is_empty_1:
   \   0000001A   E010               LDI     R17, 0
   \   0000001C   9508               RET
     61          }
     62          
     63          // Funcție folosită pentru verificarea dacă bufferul este plin

   \                                 In  segment CODE, align 2, keep-with-next
     64          int16_t is_full(round_buff_s *inBuffer) {
   \                     is_full:
   \   00000000   0198               MOVW    R19:R18, R17:R16
     65            return ((inBuffer->head + 1) % BUFFER_SIZE) == inBuffer->tail;
   \   00000002   01F9               MOVW    R31:R30, R19:R18
   \   00000004   5CE0               SUBI    R30, 192
   \   00000006   4FFF               SBCI    R31, 255
   \   00000008   8100               LD      R16, Z
   \   0000000A   E010               LDI     R17, 0
   \   0000000C   5F0F               SUBI    R16, 255
   \   0000000E   4F1F               SBCI    R17, 255
   \   00000010   E440               LDI     R20, 64
   \   00000012   E050               LDI     R21, 0
   \   00000014   ........           CALL    ?SS_DIVMOD_L02
   \   00000018   5B2F               SUBI    R18, 191
   \   0000001A   4F3F               SBCI    R19, 255
   \   0000001C   01F9               MOVW    R31:R30, R19:R18
   \   0000001E   8100               LD      R16, Z
   \   00000020   E010               LDI     R17, 0
   \   00000022   1740               CP      R20, R16
   \   00000024   0751               CPC     R21, R17
   \   00000026   F411               BRNE    ??is_full_0
   \   00000028   E001               LDI     R16, 1
   \   0000002A   C001               RJMP    ??is_full_1
   \                     ??is_full_0:
   \   0000002C   E000               LDI     R16, 0
   \                     ??is_full_1:
   \   0000002E   E010               LDI     R17, 0
   \   00000030   9508               RET
     66          }

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   is_empty
      0      2   is_full
        0      2 ?SS_DIVMOD_L02
      2      2   pop
        2      2   -> is_empty
        2      2 ?SS_DIVMOD_L02
      4      2   push
        4      2   -> is_full
        4      2 ?SS_DIVMOD_L02
      8      2   push_vec
        8      2   -> push


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      30  is_empty
      50  is_full
      74  pop
      82  push
      48  push_vec

 
 284 bytes in segment CODE
 
 284 bytes of CODE memory

Errors: none
Warnings: none
